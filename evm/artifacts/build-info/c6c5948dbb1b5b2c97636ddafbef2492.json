{
	"id": "c6c5948dbb1b5b2c97636ddafbef2492",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23+commit.f704f362",
	"input": {
		"language": "Solidity",
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 200
			},
			"viaIR": true,
			"outputSelection": {
				"*": {
					"*": [
						"evm.bytecode",
						"evm.deployedBytecode",
						"devdoc",
						"userdoc",
						"metadata",
						"abi"
					]
				}
			},
			"remappings": []
		},
		"sources": {
			"contracts/RemainingInvalidatorLib.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype RemainingInvalidator is uint256;\n\n/**\n * @title RemainingInvalidatorLib\n * @notice The library provides a mechanism to invalidate order based on the remaining amount of the order.\n * @dev The remaining amount is used as a nonce to invalidate the order.\n * When order is created, the remaining invalidator is 0.\n * When order is filled, the remaining invalidator is the inverse of the remaining amount.\n */\nlibrary RemainingInvalidatorLib {\n\n    /// @dev The error is thrown when an attempt is made to invalidate an already invalidated entity.\n    error RemainingInvalidatedOrder();\n\n    /**\n     * @notice Checks if an order is new based on the invalidator value.\n     * @param invalidator The remaining invalidator of the order.\n     * @return result Whether the order is new or not.\n     */\n    function isNewOrder(RemainingInvalidator invalidator) internal pure returns(bool) {\n        return RemainingInvalidator.unwrap(invalidator) == 0;\n    }\n\n    /**\n     * @notice Retrieves the remaining amount for an order.\n     * @dev If the order is unknown, a RemainingInvalidatedOrder error is thrown.\n     * @param invalidator The remaining invalidator for the order.\n     * @return result The remaining amount for the order.\n     */\n    function remaining(RemainingInvalidator invalidator) internal pure returns(uint256) {\n        uint256 value = RemainingInvalidator.unwrap(invalidator);\n        if (value == 0) {\n            revert RemainingInvalidatedOrder();\n        }\n        unchecked {\n            return ~value;\n        }\n    }\n\n    /**\n     * @notice Calculates the remaining amount for an order.\n     * @dev If the order is unknown, the order maker amount is returned.\n     * @param invalidator The remaining invalidator for the order.\n     * @param orderMakerAmount The amount to return if the order is new.\n     * @return result The remaining amount for the order.\n     */\n    function remaining(RemainingInvalidator invalidator, uint256 orderMakerAmount) internal pure returns(uint256) {\n        uint256 value = RemainingInvalidator.unwrap(invalidator);\n        if (value == 0) {\n            return orderMakerAmount;\n        }\n        unchecked {\n            return ~value;\n        }\n    }\n\n    /**\n     * @notice Calculates the remaining invalidator of the order.\n     * @param remainingMakingAmount The remaining making amount of the order.\n     * @param makingAmount The making amount of the order.\n     * @return result The remaining invalidator for the order.\n     */\n    function remains(uint256 remainingMakingAmount, uint256 makingAmount) internal pure returns(RemainingInvalidator) {\n        unchecked {\n            return RemainingInvalidator.wrap(~(remainingMakingAmount - makingAmount));\n        }\n    }\n\n    /**\n     * @notice Provides the remaining invalidator for a fully filled order.\n     * @return result The remaining invalidator for a fully filled order.\n     */\n    function fullyFilled() internal pure returns(RemainingInvalidator) {\n        return RemainingInvalidator.wrap(type(uint256).max);\n    }\n}"
			}
		}
	},
	"output": {
		"contracts": {
			"contracts/RemainingInvalidatorLib.sol": {
				"RemainingInvalidatorLib": {
					"abi": [
						{
							"inputs": [],
							"name": "RemainingInvalidatedOrder",
							"type": "error"
						}
					],
					"devdoc": {
						"details": "The remaining amount is used as a nonce to invalidate the order. When order is created, the remaining invalidator is 0. When order is filled, the remaining invalidator is the inverse of the remaining amount.",
						"errors": {
							"RemainingInvalidatedOrder()": [
								{
									"details": "The error is thrown when an attempt is made to invalidate an already invalidated entity."
								}
							]
						},
						"kind": "dev",
						"methods": {},
						"title": "RemainingInvalidatorLib",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212207584519439c37a49c55b067896be0cd7cfe0d07b652bfa9b32e70022e0e8985f64736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH22 0x84519439C37A49C55B067896BE0CD7CFE0D07B652BFA SWAP12 ORIGIN 0xE7 STOP 0x22 0xE0 0xE8 SWAP9 PUSH0 PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "469:2631:0:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea26469706673582212207584519439c37a49c55b067896be0cd7cfe0d07b652bfa9b32e70022e0e8985f64736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH22 0x84519439C37A49C55B067896BE0CD7CFE0D07B652BFA SWAP12 ORIGIN 0xE7 STOP 0x22 0xE0 0xE8 SWAP9 PUSH0 PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "469:2631:0:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"RemainingInvalidatedOrder\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"The remaining amount is used as a nonce to invalidate the order. When order is created, the remaining invalidator is 0. When order is filled, the remaining invalidator is the inverse of the remaining amount.\",\"errors\":{\"RemainingInvalidatedOrder()\":[{\"details\":\"The error is thrown when an attempt is made to invalidate an already invalidated entity.\"}]},\"kind\":\"dev\",\"methods\":{},\"title\":\"RemainingInvalidatorLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"The library provides a mechanism to invalidate order based on the remaining amount of the order.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RemainingInvalidatorLib.sol\":\"RemainingInvalidatorLib\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/RemainingInvalidatorLib.sol\":{\"keccak256\":\"0x192440c67bd53e14ab492c5bf4d65ce44055272cf4e80950d601a5af0db567fc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8389ea1731fbb20c5b5f19da828c1e4f4146b8a94d033df70bc34f2674b484ea\",\"dweb:/ipfs/QmXacGH2xWNnN3SrS27QKykd7rUKpmMCrffNwQtq6L8ZG5\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"notice": "The library provides a mechanism to invalidate order based on the remaining amount of the order.",
						"version": 1
					}
				}
			}
		},
		"sources": {
			"contracts/RemainingInvalidatorLib.sol": {
				"id": 0
			}
		}
	}
}