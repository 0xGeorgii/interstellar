{
	"id": "ecd4dbfd2a6064335bd4f4b73d06fe7c",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23+commit.f704f362",
	"input": {
		"language": "Solidity",
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 200
			},
			"viaIR": true,
			"outputSelection": {
				"*": {
					"*": [
						"evm.bytecode",
						"evm.deployedBytecode",
						"devdoc",
						"userdoc",
						"metadata",
						"abi"
					]
				}
			},
			"remappings": []
		},
		"sources": {
			"contracts/escrow/EscrowSrc.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"../IERC20.sol\";\nimport { SafeERC20 } from \"../SafeERC20.sol\";\nimport { AddressLib, Address } from \"../AddressLib.sol\";\n\nimport { Timelocks, TimelocksLib } from \"./libraries/TimelocksLib.sol\";\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\n\nimport { IEscrowSrc } from \"./interfaces/IEscrowSrc.sol\";\nimport { BaseEscrow } from \"./BaseEscrow.sol\";\nimport { Escrow } from \"./Escrow.sol\";\n\n/**\n * @title Source Escrow contract for cross-chain atomic swap.\n * @notice Contract to initially lock funds and then unlock them with verification of the secret presented.\n * @dev Funds are locked in at the time of contract deployment. For this Limit Order Protocol\n * calls the `EscrowFactory.postInteraction` function.\n * To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.\n * @custom:security-contact security@1inch.io\n */\ncontract EscrowSrc is Escrow, IEscrowSrc {\n    using AddressLib for Address;\n    using ImmutablesLib for Immutables;\n    using SafeERC20 for IERC20;\n    using TimelocksLib for Timelocks;\n\n    constructor(uint32 rescueDelay, IERC20 accessToken) BaseEscrow(rescueDelay, accessToken) {}\n\n    /**\n     * @notice See {IBaseEscrow-withdraw}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/--\n     * --/-- private cancellation --/-- public cancellation ----\n     */\n    function withdraw(bytes32 secret, Immutables calldata immutables)\n        external\n        onlyTaker(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _withdrawTo(secret, msg.sender, immutables);\n    }\n\n    /**\n     * @notice See {IEscrowSrc-withdrawTo}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/--\n     * --/-- private cancellation --/-- public cancellation ----\n     */\n    function withdrawTo(bytes32 secret, address target, Immutables calldata immutables)\n        external\n        onlyTaker(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _withdrawTo(secret, target, immutables);\n    }\n\n    /**\n     * @notice See {IEscrowSrc-publicWithdraw}.\n     * @dev The function works on the time interval highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/--\n     * --/-- private cancellation --/-- public cancellation ----\n     */\n    function publicWithdraw(bytes32 secret, Immutables calldata immutables)\n        external\n        onlyAccessTokenHolder()\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcPublicWithdrawal))\n        onlyBefore(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _withdrawTo(secret, immutables.taker.get(), immutables);\n    }\n\n    /**\n     * @notice See {IBaseEscrow-cancel}.\n     * @dev The function works on the time intervals highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/--\n     * --/-- PRIVATE CANCELLATION --/-- PUBLIC CANCELLATION ----\n     */\n    function cancel(Immutables calldata immutables)\n        external\n        onlyTaker(immutables)\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation))\n    {\n        _cancel(immutables);\n    }\n\n    /**\n     * @notice See {IEscrowSrc-publicCancel}.\n     * @dev The function works on the time intervals highlighted with capital letters:\n     * ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/--\n     * --/-- private cancellation --/-- PUBLIC CANCELLATION ----\n     */\n    function publicCancel(Immutables calldata immutables)\n        external\n        onlyAccessTokenHolder()\n        onlyAfter(immutables.timelocks.get(TimelocksLib.Stage.SrcPublicCancellation))\n    {\n        _cancel(immutables);\n    }\n\n    /**\n     * @dev Transfers ERC20 tokens to the target and native tokens to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param target The address to transfer ERC20 tokens to.\n     * @param immutables The immutable values used to deploy the clone contract.\n     */\n    function _withdrawTo(bytes32 secret, address target, Immutables calldata immutables)\n        internal\n        onlyValidImmutables(immutables)\n        onlyValidSecret(secret, immutables)\n    {\n        IERC20(immutables.token.get()).safeTransfer(target, immutables.amount);\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\n        emit EscrowWithdrawal(secret);\n    }\n\n    /**\n     * @dev Transfers ERC20 tokens to the maker and native tokens to the caller.\n     * @param immutables The immutable values used to deploy the clone contract.\n     */\n    function _cancel(Immutables calldata immutables) internal onlyValidImmutables(immutables) {\n        IERC20(immutables.token.get()).safeTransfer(immutables.maker.get(), immutables.amount);\n        _ethTransfer(msg.sender, immutables.safetyDeposit);\n        emit EscrowCancelled();\n    }\n}\n"
			},
			"contracts/escrow/Escrow.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { Create2 } from \"./Create2.sol\";\n\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\nimport { ProxyHashLib } from \"./libraries/ProxyHashLib.sol\";\n\nimport { IEscrow } from \"./interfaces/IEscrow.sol\";\nimport { BaseEscrow } from \"./BaseEscrow.sol\";\n\n/**\n * @title Abstract Escrow contract for cross-chain atomic swap.\n * @dev {IBaseEscrow-withdraw} and {IBaseEscrow-cancel} functions must be implemented in the derived contracts.\n * @custom:security-contact security@1inch.io\n */\nabstract contract Escrow is BaseEscrow, IEscrow {\n    using ImmutablesLib for Immutables;\n\n    /// @notice See {IEscrow-PROXY_BYTECODE_HASH}.\n    bytes32 public immutable PROXY_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(address(this));\n\n\n    /**\n     * @dev Verifies that the computed escrow address matches the address of this contract.\n     */\n    function _validateImmutables(Immutables calldata immutables) internal view virtual override {\n        bytes32 salt = immutables.hash();\n        if (Create2.computeAddress(salt, PROXY_BYTECODE_HASH, FACTORY) != address(this)) {\n            revert InvalidImmutables();\n        }\n    }\n}\n"
			},
			"contracts/escrow/BaseEscrow.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"../IERC20.sol\";\nimport { AddressLib, Address } from \"../AddressLib.sol\";\nimport { SafeERC20 } from \"../SafeERC20.sol\";\n\nimport { ImmutablesLib } from \"./libraries/ImmutablesLib.sol\";\nimport { Timelocks, TimelocksLib } from \"./libraries/TimelocksLib.sol\";\n\nimport { IBaseEscrow } from \"./interfaces/IBaseEscrow.sol\";\n\n/**\n * @title Base abstract Escrow contract for cross-chain atomic swap.\n * @dev {IBaseEscrow-withdraw}, {IBaseEscrow-cancel} and _validateImmutables functions must be implemented in the derived contracts.\n * @custom:security-contact security@1inch.io\n */\nabstract contract BaseEscrow is IBaseEscrow {\n    using AddressLib for Address;\n    using SafeERC20 for IERC20;\n    using TimelocksLib for Timelocks;\n    using ImmutablesLib for Immutables;\n\n    // Token that is used to access public withdraw or cancel functions.\n    IERC20 private immutable _ACCESS_TOKEN;\n\n    /// @notice See {IBaseEscrow-RESCUE_DELAY}.\n    uint256 public immutable RESCUE_DELAY;\n    /// @notice See {IBaseEscrow-FACTORY}.\n    address public immutable FACTORY = msg.sender;\n\n    constructor(uint32 rescueDelay, IERC20 accessToken) {\n        RESCUE_DELAY = rescueDelay;\n        _ACCESS_TOKEN = accessToken;\n    }\n\n    modifier onlyTaker(Immutables calldata immutables) {\n        if (msg.sender != immutables.taker.get()) revert InvalidCaller();\n        _;\n    }\n\n    modifier onlyValidImmutables(Immutables calldata immutables) virtual {\n        _validateImmutables(immutables);\n        _;\n    }\n\n    modifier onlyValidSecret(bytes32 secret, Immutables calldata immutables) {\n        if (_keccakBytes32(secret) != immutables.hashlock) revert InvalidSecret();\n        _;\n    }\n\n    modifier onlyAfter(uint256 start) {\n        if (block.timestamp < start) revert InvalidTime();\n        _;\n    }\n\n    modifier onlyBefore(uint256 stop) {\n        if (block.timestamp >= stop) revert InvalidTime();\n        _;\n    }\n\n    modifier onlyAccessTokenHolder() {\n        if (_ACCESS_TOKEN.balanceOf(msg.sender) == 0) revert InvalidCaller();\n        _;\n    }\n\n    /**\n     * @notice See {IBaseEscrow-rescueFunds}.\n     */\n    function rescueFunds(address token, uint256 amount, Immutables calldata immutables)\n        external\n        onlyTaker(immutables)\n        onlyValidImmutables(immutables)\n        onlyAfter(immutables.timelocks.rescueStart(RESCUE_DELAY))\n    {\n        _uniTransfer(token, msg.sender, amount);\n        emit FundsRescued(token, amount);\n    }\n\n    /**\n     * @dev Transfers ERC20 or native tokens to the recipient.\n     */\n    function _uniTransfer(address token, address to, uint256 amount) internal {\n        if (token == address(0)) {\n            _ethTransfer(to, amount);\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev Transfers native tokens to the recipient.\n     */\n    function _ethTransfer(address to, uint256 amount) internal {\n        (bool success,) = to.call{ value: amount }(\"\");\n        if (!success) revert NativeTokenSendingFailure();\n    }\n\n    /**\n     * @dev Should verify that the computed escrow address matches the address of this contract.\n     */\n    function _validateImmutables(Immutables calldata immutables) internal view virtual;\n\n    /**\n     * @dev Computes the Keccak-256 hash of the secret.\n     * @param secret The secret that unlocks the escrow.\n     * @return ret The computed hash.\n     */\n    function _keccakBytes32(bytes32 secret) private pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            mstore(0, secret)\n            ret := keccak256(0, 0x20)\n        }\n    }\n}\n"
			},
			"contracts/escrow/interfaces/IEscrowSrc.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IEscrow } from \"./IEscrow.sol\";\n\n/**\n * @title Source Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrowSrc is IEscrow {\n    /**\n     * @notice Withdraws funds to a specified target.\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\n     * The safety deposit is sent to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param target The address to withdraw the funds to.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function withdrawTo(bytes32 secret, address target, IEscrow.Immutables calldata immutables) external;\n\n    /**\n     * @notice Withdraws funds to the taker.\n     * @dev Withdrawal can only be made during the public withdrawal period and with secret with hash matches the hashlock.\n     * @param secret The secret that unlocks the escrow.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function publicWithdraw(bytes32 secret, Immutables calldata immutables) external;\n\n    /**\n     * @notice Cancels the escrow and returns tokens to the maker.\n     * @dev The escrow can only be cancelled during the public cancellation period.\n     * The safety deposit is sent to the caller.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function publicCancel(IEscrow.Immutables calldata immutables) external;\n}\n"
			},
			"contracts/escrow/libraries/ImmutablesLib.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IBaseEscrow } from \"../interfaces/IBaseEscrow.sol\";\n\n/**\n * @title Library for escrow immutables.\n * @custom:security-contact security@1inch.io\n */\nlibrary ImmutablesLib {\n    uint256 internal constant ESCROW_IMMUTABLES_SIZE = 0x100;\n\n    /**\n     * @notice Returns the hash of the immutables.\n     * @param immutables The immutables to hash.\n     * @return ret The computed hash.\n     */\n    function hash(IBaseEscrow.Immutables calldata immutables) internal pure returns(bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, immutables, ESCROW_IMMUTABLES_SIZE)\n            ret := keccak256(ptr, ESCROW_IMMUTABLES_SIZE)\n        }\n    }\n\n    /**\n     * @notice Returns the hash of the immutables.\n     * @param immutables The immutables to hash.\n     * @return ret The computed hash.\n     */\n    function hashMem(IBaseEscrow.Immutables memory immutables) internal pure returns(bytes32 ret) {\n        assembly (\"memory-safe\") {\n            ret := keccak256(immutables, ESCROW_IMMUTABLES_SIZE)\n        }\n    }\n}\n"
			},
			"contracts/escrow/libraries/TimelocksLib.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Timelocks for the source and the destination chains plus the deployment timestamp.\n * Timelocks store the number of seconds from the time the contract is deployed to the start of a specific period.\n * For illustrative purposes, it is possible to describe timelocks by two structures:\n * struct SrcTimelocks {\n *     uint256 withdrawal;\n *     uint256 publicWithdrawal;\n *     uint256 cancellation;\n *     uint256 publicCancellation;\n * }\n *\n * struct DstTimelocks {\n *     uint256 withdrawal;\n *     uint256 publicWithdrawal;\n *     uint256 cancellation;\n * }\n *\n * withdrawal: Period when only the taker with a secret can withdraw tokens for taker (source chain) or maker (destination chain).\n * publicWithdrawal: Period when anyone with a secret can withdraw tokens for taker (source chain) or maker (destination chain).\n * cancellation: Period when escrow can only be cancelled by the taker.\n * publicCancellation: Period when escrow can be cancelled by anyone.\n *\n * @custom:security-contact security@1inch.io\n */\ntype Timelocks is uint256;\n\n/**\n * @title Timelocks library for compact storage of timelocks in a uint256.\n */\nlibrary TimelocksLib {\n    enum Stage {\n        SrcWithdrawal,\n        SrcPublicWithdrawal,\n        SrcCancellation,\n        SrcPublicCancellation,\n        DstWithdrawal,\n        DstPublicWithdrawal,\n        DstCancellation\n    }\n\n    uint256 private constant _DEPLOYED_AT_MASK = 0xffffffff00000000000000000000000000000000000000000000000000000000;\n    uint256 private constant _DEPLOYED_AT_OFFSET = 224;\n\n    /**\n     * @notice Sets the Escrow deployment timestamp.\n     * @param timelocks The timelocks to set the deployment timestamp to.\n     * @param value The new Escrow deployment timestamp.\n     * @return The timelocks with the deployment timestamp set.\n     */\n    function setDeployedAt(Timelocks timelocks, uint256 value) internal pure returns (Timelocks) {\n        return Timelocks.wrap((Timelocks.unwrap(timelocks) & ~uint256(_DEPLOYED_AT_MASK)) | value << _DEPLOYED_AT_OFFSET);\n    }\n\n    /**\n     * @notice Returns the start of the rescue period.\n     * @param timelocks The timelocks to get the rescue delay from.\n     * @return The start of the rescue period.\n     */\n    function rescueStart(Timelocks timelocks, uint256 rescueDelay) internal pure returns (uint256) {\n        unchecked {\n            return rescueDelay + (Timelocks.unwrap(timelocks) >> _DEPLOYED_AT_OFFSET);\n        }\n    }\n\n    /**\n     * @notice Returns the timelock value for the given stage.\n     * @param timelocks The timelocks to get the value from.\n     * @param stage The stage to get the value for.\n     * @return The timelock value for the given stage.\n     */\n    function get(Timelocks timelocks, Stage stage) internal pure returns (uint256) {\n        uint256 data = Timelocks.unwrap(timelocks);\n        uint256 bitShift = uint256(stage) * 32;\n        // The maximum uint32 value will be reached in 2106.\n        return (data >> _DEPLOYED_AT_OFFSET) + uint32(data >> bitShift);\n    }\n}\n"
			},
			"contracts/AddressLib.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype Address is uint256;\n\n/**\n* @notice AddressLib\n* @notice Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\n*/\nlibrary AddressLib {\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\n\n    /**\n    * @notice Returns the address representation of a uint256.\n    * @param a The uint256 value to convert to an address.\n    * @return The address representation of the provided uint256 value.\n    */\n    function get(Address a) internal pure returns (address) {\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\n    }\n\n    /**\n    * @notice Checks if a given flag is set for the provided address.\n    * @param a The address to check for the flag.\n    * @param flag The flag to check for in the provided address.\n    * @return True if the provided flag is set in the address, false otherwise.\n    */\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\n        return (Address.unwrap(a) & flag) != 0;\n    }\n\n    /**\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint32 value.\n    * @param offset The bit offset at which the uint32 value is stored.\n    * @return The uint32 value stored in the address at the specified bit offset.\n    */\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\n        return uint32(Address.unwrap(a) >> offset);\n    }\n\n    /**\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint64 value.\n    * @param offset The bit offset at which the uint64 value is stored.\n    * @return The uint64 value stored in the address at the specified bit offset.\n    */\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\n        return uint64(Address.unwrap(a) >> offset);\n    }\n}"
			},
			"contracts/SafeERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Permit.sol\";\nimport \"./IDaiLikePermit.sol\";\nimport \"./IPermit2.sol\";\nimport \"./IERC7597Permit.sol\";\nimport \"./IWETH.sol\";\nimport \"./RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    address private constant _PERMIT2_ZKSYNC = 0x0000000000225e31D15943971F47aD3022F714Fa;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 0x64, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        address permit2 = _getPermit2Address();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), permit2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(permit2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, amount)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        address permit2 = _getPermit2Address();\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\n            }\n            // Dynamic length\n            default {\n                mstore(ptr, erc7597PermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.deposit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    function _getPermit2Address() private view returns (address permit2) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            switch chainid()\n            case 324 { // zksync mainnet\n                permit2 := _PERMIT2_ZKSYNC\n            }\n            case 300 { // zksync testnet\n                permit2 := _PERMIT2_ZKSYNC\n            }\n            case 260 { // zksync fork network\n                permit2 := _PERMIT2_ZKSYNC\n            }\n            default {\n                permit2 := _PERMIT2\n            }\n        }\n    }\n}"
			},
			"contracts/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}"
			},
			"contracts/escrow/interfaces/IBaseEscrow.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Address } from \"../../AddressLib.sol\";\n\nimport { Timelocks } from \"../libraries/TimelocksLib.sol\";\n\n/**\n * @title Base Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IBaseEscrow {\n    struct Immutables {\n        bytes32 orderHash;\n        bytes32 hashlock;  // Hash of the secret.\n        Address maker;\n        Address taker;\n        Address token;\n        uint256 amount;\n        uint256 safetyDeposit;\n        Timelocks timelocks;\n    }\n\n    /**\n     * @notice Emitted on escrow cancellation.\n     */\n    event EscrowCancelled();\n\n    /**\n     * @notice Emitted when funds are rescued.\n     * @param token The address of the token rescued. Zero address for native token.\n     * @param amount The amount of tokens rescued.\n     */\n    event FundsRescued(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on successful withdrawal.\n     * @param secret The secret that unlocks the escrow.\n     */\n    event EscrowWithdrawal(bytes32 secret);\n\n    error InvalidCaller();\n    error InvalidImmutables();\n    error InvalidSecret();\n    error InvalidTime();\n    error NativeTokenSendingFailure();\n\n    /* solhint-disable func-name-mixedcase */\n    /// @notice Returns the delay for rescuing funds from the escrow.\n    function RESCUE_DELAY() external view returns (uint256);\n    /// @notice Returns the address of the factory that created the escrow.\n    function FACTORY() external view returns (address);\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @notice Withdraws funds to a predetermined recipient.\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\n     * The safety deposit is sent to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function withdraw(bytes32 secret, Immutables calldata immutables) external;\n\n    /**\n     * @notice Cancels the escrow and returns tokens to a predetermined recipient.\n     * @dev The escrow can only be cancelled during the cancellation period.\n     * The safety deposit is sent to the caller.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function cancel(Immutables calldata immutables) external;\n\n    /**\n     * @notice Rescues funds from the escrow.\n     * @dev Funds can only be rescued by the taker after the rescue delay.\n     * @param token The address of the token to rescue. Zero address for native token.\n     * @param amount The amount of tokens to rescue.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function rescueFunds(address token, uint256 amount, Immutables calldata immutables) external;\n}\n"
			},
			"contracts/escrow/interfaces/IEscrow.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IBaseEscrow } from \"./IBaseEscrow.sol\";\n\n/**\n * @title Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrow is IBaseEscrow {\n    /// @notice Returns the bytecode hash of the proxy contract.\n    function PROXY_BYTECODE_HASH() external view returns (bytes32); // solhint-disable-line func-name-mixedcase\n}\n"
			},
			"contracts/escrow/libraries/ProxyHashLib.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title Library to compute the hash of the proxy bytecode.\n * @custom:security-contact security@1inch.io\n */\nlibrary ProxyHashLib {\n    /**\n     * @notice Returns the hash of the proxy bytecode concatenated with the implementation address.\n     * @param implementation The address of the contract to clone.\n     * @return bytecodeHash The hash of the resulting bytecode.\n     */\n    function computeProxyBytecodeHash(address implementation) internal pure returns (bytes32 bytecodeHash) {\n        assembly (\"memory-safe\") {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            bytecodeHash := keccak256(0x09, 0x37)\n        }\n    }\n}\n"
			},
			"contracts/escrow/Create2.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
			},
			"contracts/RevertReasonForwarder.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title RevertReasonForwarder\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\n */\nlibrary RevertReasonForwarder {\n    /**\n     * @dev Forwards the revert reason from the latest external call.\n     * This method allows propagating the revert reason of a failed external call to the caller.\n     */\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n\n    /**\n     * @dev Retrieves the revert reason from the latest external call.\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\n     * @return reason The latest external call revert reason.\n     */\n    function reReason() internal pure returns (bytes memory reason) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            reason := mload(0x40)\n            let length := returndatasize()\n            mstore(reason, length)\n            returndatacopy(add(reason, 0x20), 0, length)\n            mstore(0x40, add(reason, add(0x20, length)))\n        }\n    }\n}"
			},
			"contracts/IWETH.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title IWETH\n * @dev Interface for wrapper as WETH-like token.\n */\ninterface IWETH is IERC20 {\n    /**\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\n     */\n    event Deposit(address indexed dst, uint256 wad);\n\n    /**\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\n     */\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /**\n     * @notice Deposit Ether to get wrapper tokens.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw wrapped tokens as Ether.\n     * @param amount Amount of wrapped tokens to withdraw.\n     */\n    function withdraw(uint256 amount) external;\n}"
			},
			"contracts/IERC7597Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IERC7597Permit\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\n */\ninterface IERC7597Permit {\n    /**\n     * @notice Update allowance with a signed permit.\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\n     * @param owner Token owner's address (Authorizer).\n     * @param spender Spender's address.\n     * @param value Amount of allowance.\n     * @param deadline The time at which the signature expires (unixtime).\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n}"
			},
			"contracts/IPermit2.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPermit2\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\n */\ninterface IPermit2 {\n    /**\n     * @dev Struct for holding permit details.\n     * @param token ERC20 token address for which the permit is issued.\n     * @param amount The maximum amount allowed to spend.\n     * @param expiration Timestamp until which the permit is valid.\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\n     */\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @dev Struct for a single token allowance permit.\n     * @param details Permit details including token, amount, expiration, and nonce.\n     * @param spender Address authorized to spend the tokens.\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\n     */\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    /**\n     * @dev Struct for packed allowance data to optimize storage.\n     * @param amount Amount allowed.\n     * @param expiration Permission expiry timestamp.\n     * @param nonce Unique incrementing value for tracking allowances.\n     */\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @notice Executes a token transfer from one address to another.\n     * @param user The token owner's address.\n     * @param spender The address authorized to spend the tokens.\n     * @param amount The amount of tokens to transfer.\n     * @param token The address of the token being transferred.\n     */\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    /**\n     * @notice Issues a permit for spending tokens via a signed authorization.\n     * @param owner The token owner's address.\n     * @param permitSingle Struct containing the permit details.\n     * @param signature The signature proving the owner authorized the permit.\n     */\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Retrieves the allowance details between a token owner and spender.\n     * @param user The token owner's address.\n     * @param token The token address.\n     * @param spender The spender's address.\n     * @return The packed allowance details.\n     */\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n\n    /**\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\n     * @param token The token to approve\n     * @param spender The spender address to approve\n     * @param amount The approved amount of the token\n     * @param expiration The timestamp at which the approval is no longer valid\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\n     */\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n}"
			},
			"contracts/IDaiLikePermit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IDaiLikePermit\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\n */\ninterface IDaiLikePermit {\n    /**\n     * @notice Approves spending of tokens via off-chain signatures.\n     * @param holder Token holder's address.\n     * @param spender Spender's address.\n     * @param nonce Current nonce of the holder.\n     * @param expiry Time when the permit expires.\n     * @param allowed True to allow, false to disallow spending.\n     * @param v, r, s Signature components.\n     */\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}"
			},
			"contracts/IERC20Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
			},
			"contracts/Errors.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
			}
		}
	},
	"output": {
		"contracts": {
			"contracts/AddressLib.sol": {
				"AddressLib": {
					"abi": [],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212200b66fab8a5026a63a0b15f033e8dd4cd45dc3c312a4babf612f876c3816240e264736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SIGNEXTEND PUSH7 0xFAB8A5026A63A0 0xB1 PUSH0 SUB RETURNDATACOPY DUP14 0xD4 0xCD GASLIMIT 0xDC EXTCODECOPY BALANCE 0x2A 0x4B 0xAB 0xF6 SLT 0xF8 PUSH23 0xC3816240E264736F6C6343000817003300000000000000 ",
							"sourceMap": "229:1771:0:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea26469706673582212200b66fab8a5026a63a0b15f033e8dd4cd45dc3c312a4babf612f876c3816240e264736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SIGNEXTEND PUSH7 0xFAB8A5026A63A0 0xB1 PUSH0 SUB RETURNDATACOPY DUP14 0xD4 0xCD GASLIMIT 0xDC EXTCODECOPY BALANCE 0x2A 0x4B 0xAB 0xF6 SLT 0xF8 PUSH23 0xC3816240E264736F6C6343000817003300000000000000 ",
							"sourceMap": "229:1771:0:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"AddressLibLibrary for working with addresses encoded as uint256 values, which can include flags in the highest bits.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AddressLib.sol\":\"AddressLib\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"notice": "AddressLibLibrary for working with addresses encoded as uint256 values, which can include flags in the highest bits.",
						"version": 1
					}
				}
			},
			"contracts/Errors.sol": {
				"Errors": {
					"abi": [
						{
							"inputs": [],
							"name": "FailedCall",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "FailedDeployment",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "balance",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "needed",
									"type": "uint256"
								}
							],
							"name": "InsufficientBalance",
							"type": "error"
						}
					],
					"devdoc": {
						"details": "Collection of common custom errors used in multiple contracts IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library. It is recommended to avoid relying on the error API for critical functionality.",
						"errors": {
							"FailedCall()": [
								{
									"details": "A call to an address target failed. The target may have reverted."
								}
							],
							"FailedDeployment()": [
								{
									"details": "The deployment failed."
								}
							],
							"InsufficientBalance(uint256,uint256)": [
								{
									"details": "The ETH balance of the account is not enough to perform the operation."
								}
							]
						},
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212200a90f8c8f150996695e139ea9852e6941b17714b90f1e86eb936cbd2464ded8264736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 EXP SWAP1 0xF8 0xC8 CALL POP SWAP10 PUSH7 0x95E139EA9852E6 SWAP5 SHL OR PUSH18 0x4B90F1E86EB936CBD2464DED8264736F6C63 NUMBER STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "314:382:1:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea26469706673582212200a90f8c8f150996695e139ea9852e6941b17714b90f1e86eb936cbd2464ded8264736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 EXP SWAP1 0xF8 0xC8 CALL POP SWAP10 PUSH7 0x95E139EA9852E6 SWAP5 SHL OR PUSH18 0x4B90F1E86EB936CBD2464DED8264736F6C63 NUMBER STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "314:382:1:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"FailedCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedDeployment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Collection of common custom errors used in multiple contracts IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library. It is recommended to avoid relying on the error API for critical functionality.\",\"errors\":{\"FailedCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"FailedDeployment()\":[{\"details\":\"The deployment failed.\"}],\"InsufficientBalance(uint256,uint256)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Errors.sol\":\"Errors\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/Errors.sol\":{\"keccak256\":\"0x1b0625096e82d06abdcf1844172ef78ef54a5e878761f4d905fda07eaf098424\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5cd99f1a4836c07461cb3ea023ae2f6d1d01e80694b764a87623aa7252754756\",\"dweb:/ipfs/QmNPNDuiNU6TJatZcdBcrwixBoo5MSXNDq4kaXhpJLWGpB\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"contracts/IDaiLikePermit.sol": {
				"IDaiLikePermit": {
					"abi": [
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "holder",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "nonce",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "expiry",
									"type": "uint256"
								},
								{
									"internalType": "bool",
									"name": "allowed",
									"type": "bool"
								},
								{
									"internalType": "uint8",
									"name": "v",
									"type": "uint8"
								},
								{
									"internalType": "bytes32",
									"name": "r",
									"type": "bytes32"
								},
								{
									"internalType": "bytes32",
									"name": "s",
									"type": "bytes32"
								}
							],
							"name": "permit",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"details": "Interface for Dai-like permit function allowing token spending via signatures.",
						"kind": "dev",
						"methods": {
							"permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)": {
								"params": {
									"allowed": "True to allow, false to disallow spending.",
									"expiry": "Time when the permit expires.",
									"holder": "Token holder's address.",
									"nonce": "Current nonce of the holder.",
									"spender": "Spender's address.",
									"v": ", r, s Signature components."
								}
							}
						},
						"title": "IDaiLikePermit",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface for Dai-like permit function allowing token spending via signatures.\",\"kind\":\"dev\",\"methods\":{\"permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)\":{\"params\":{\"allowed\":\"True to allow, false to disallow spending.\",\"expiry\":\"Time when the permit expires.\",\"holder\":\"Token holder's address.\",\"nonce\":\"Current nonce of the holder.\",\"spender\":\"Spender's address.\",\"v\":\", r, s Signature components.\"}}},\"title\":\"IDaiLikePermit\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)\":{\"notice\":\"Approves spending of tokens via off-chain signatures.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IDaiLikePermit.sol\":\"IDaiLikePermit\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IDaiLikePermit.sol\":{\"keccak256\":\"0x0bcc9c886acb32f5664e3bfd0640e6fc1de6525b8f6103f25906d040d054ce07\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://551e3b7d18d5e83727491f6749643a9a1e9a2e253a1a9be56eeb44e4c1b13876\",\"dweb:/ipfs/QmSpGRSD3DDP1EbBbXDPqAbSP58roEvCsosMQCDtSDnEBa\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {
							"permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)": {
								"notice": "Approves spending of tokens via off-chain signatures."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/IERC20.sol": {
				"IERC20": {
					"abi": [
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "Approval",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "from",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "to",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "Transfer",
							"type": "event"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								}
							],
							"name": "allowance",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "approve",
							"outputs": [
								{
									"internalType": "bool",
									"name": "",
									"type": "bool"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "account",
									"type": "address"
								}
							],
							"name": "balanceOf",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "totalSupply",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "to",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "transfer",
							"outputs": [
								{
									"internalType": "bool",
									"name": "",
									"type": "bool"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "from",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "to",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "transferFrom",
							"outputs": [
								{
									"internalType": "bool",
									"name": "",
									"type": "bool"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"details": "Interface of the ERC-20 standard as defined in the ERC.",
						"events": {
							"Approval(address,address,uint256)": {
								"details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
							},
							"Transfer(address,address,uint256)": {
								"details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
							}
						},
						"kind": "dev",
						"methods": {
							"allowance(address,address)": {
								"details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
							},
							"approve(address,uint256)": {
								"details": "Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
							},
							"balanceOf(address)": {
								"details": "Returns the value of tokens owned by `account`."
							},
							"totalSupply()": {
								"details": "Returns the value of tokens in existence."
							},
							"transfer(address,uint256)": {
								"details": "Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
							},
							"transferFrom(address,address,uint256)": {
								"details": "Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
							}
						},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC-20 standard as defined in the ERC.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the value of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the value of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IERC20.sol\":\"IERC20\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IERC20.sol\":{\"keccak256\":\"0x91104f4bcc877f2506e4485b871efe0a6beb5c1ef7de9c374d99d75289905905\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://57a7ecbec5ff542c117d36c7487386b5653ad21d0a83414e859d4202e069b36f\",\"dweb:/ipfs/QmaPocSUaysdjd1Ksa5kttxRHxhA7XWd6HrQ9teLFRyR6W\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"contracts/IERC20Permit.sol": {
				"IERC20Permit": {
					"abi": [
						{
							"inputs": [],
							"name": "DOMAIN_SEPARATOR",
							"outputs": [
								{
									"internalType": "bytes32",
									"name": "",
									"type": "bytes32"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								}
							],
							"name": "nonces",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "deadline",
									"type": "uint256"
								},
								{
									"internalType": "uint8",
									"name": "v",
									"type": "uint8"
								},
								{
									"internalType": "bytes32",
									"name": "r",
									"type": "bytes32"
								},
								{
									"internalType": "bytes32",
									"name": "s",
									"type": "bytes32"
								}
							],
							"name": "permit",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"details": "Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[ERC-2612]. Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't need to send a transaction, and thus is not required to hold Ether at all. ==== Security Considerations There are two important considerations concerning the use of `permit`. The first is that a valid permit signature expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be considered as an intention to spend the allowance in any specific way. The second is that because permits have built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be generally recommended is: ```solidity function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}     doThing(..., value); } function doThing(..., uint256 value) public {     token.safeTransferFrom(msg.sender, address(this), value);     ... } ``` Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also {SafeERC20-safeTransferFrom}). Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so contracts should have entry points that don't rely on permit.",
						"kind": "dev",
						"methods": {
							"DOMAIN_SEPARATOR()": {
								"details": "Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}."
							},
							"nonces(address)": {
								"details": "Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times."
							},
							"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": {
								"details": "Sets `value` as the allowance of `spender` over ``owner``'s tokens, given ``owner``'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section]. CAUTION: See Security Considerations above."
							}
						},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[ERC-2612]. Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't need to send a transaction, and thus is not required to hold Ether at all. ==== Security Considerations There are two important considerations concerning the use of `permit`. The first is that a valid permit signature expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be considered as an intention to spend the allowance in any specific way. The second is that because permits have built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be generally recommended is: ```solidity function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}     doThing(..., value); } function doThing(..., uint256 value) public {     token.safeTransferFrom(msg.sender, address(this), value);     ... } ``` Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also {SafeERC20-safeTransferFrom}). Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so contracts should have entry points that don't rely on permit.\",\"kind\":\"dev\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"details\":\"Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\"},\"nonces(address)\":{\"details\":\"Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times.\"},\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\":{\"details\":\"Sets `value` as the allowance of `spender` over ``owner``'s tokens, given ``owner``'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section]. CAUTION: See Security Considerations above.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IERC20Permit.sol\":\"IERC20Permit\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IERC20Permit.sol\":{\"keccak256\":\"0x08d82b52e80c1a83f792c519388ca1ae86ae441bdfbd7d84addc82ef9c499a9e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a5449dde3b5541f3f653b352bfa0aa4f3e91ab24a110106319baa83940f540a5\",\"dweb:/ipfs/QmUuadcLdSPtqMuuhBgkdAZHrE3tx5rdQ7HCXCsa8RDaTU\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"contracts/IERC7597Permit.sol": {
				"IERC7597Permit": {
					"abi": [
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "deadline",
									"type": "uint256"
								},
								{
									"internalType": "bytes",
									"name": "signature",
									"type": "bytes"
								}
							],
							"name": "permit",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"details": "A new extension for ERC-2612 permit, which has already been added to USDC v2.2.",
						"kind": "dev",
						"methods": {
							"permit(address,address,uint256,uint256,bytes)": {
								"details": "Signature bytes can be used for both EOA wallets and contract wallets.",
								"params": {
									"deadline": "The time at which the signature expires (unixtime).",
									"owner": "Token owner's address (Authorizer).",
									"signature": "Unstructured bytes signature signed by an EOA wallet or a contract wallet.",
									"spender": "Spender's address.",
									"value": "Amount of allowance."
								}
							}
						},
						"title": "IERC7597Permit",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\",\"kind\":\"dev\",\"methods\":{\"permit(address,address,uint256,uint256,bytes)\":{\"details\":\"Signature bytes can be used for both EOA wallets and contract wallets.\",\"params\":{\"deadline\":\"The time at which the signature expires (unixtime).\",\"owner\":\"Token owner's address (Authorizer).\",\"signature\":\"Unstructured bytes signature signed by an EOA wallet or a contract wallet.\",\"spender\":\"Spender's address.\",\"value\":\"Amount of allowance.\"}}},\"title\":\"IERC7597Permit\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"permit(address,address,uint256,uint256,bytes)\":{\"notice\":\"Update allowance with a signed permit.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IERC7597Permit.sol\":\"IERC7597Permit\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IERC7597Permit.sol\":{\"keccak256\":\"0x550ff037524afe9ef46d2c54ed59f4048c4216122e80da3b17872e05c163a74e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://40df00df81d4a4d2a78105bf5b86694037d885abf30e1e47e286b6e3310bdf48\",\"dweb:/ipfs/QmVqmS8BpSMV8PeiUme1tNDq48zfn71XYxWhb6fLtxCT6f\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {
							"permit(address,address,uint256,uint256,bytes)": {
								"notice": "Update allowance with a signed permit."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/IPermit2.sol": {
				"IPermit2": {
					"abi": [
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "user",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								}
							],
							"name": "allowance",
							"outputs": [
								{
									"components": [
										{
											"internalType": "uint160",
											"name": "amount",
											"type": "uint160"
										},
										{
											"internalType": "uint48",
											"name": "expiration",
											"type": "uint48"
										},
										{
											"internalType": "uint48",
											"name": "nonce",
											"type": "uint48"
										}
									],
									"internalType": "struct IPermit2.PackedAllowance",
									"name": "",
									"type": "tuple"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint160",
									"name": "amount",
									"type": "uint160"
								},
								{
									"internalType": "uint48",
									"name": "expiration",
									"type": "uint48"
								}
							],
							"name": "approve",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"components": [
										{
											"components": [
												{
													"internalType": "address",
													"name": "token",
													"type": "address"
												},
												{
													"internalType": "uint160",
													"name": "amount",
													"type": "uint160"
												},
												{
													"internalType": "uint48",
													"name": "expiration",
													"type": "uint48"
												},
												{
													"internalType": "uint48",
													"name": "nonce",
													"type": "uint48"
												}
											],
											"internalType": "struct IPermit2.PermitDetails",
											"name": "details",
											"type": "tuple"
										},
										{
											"internalType": "address",
											"name": "spender",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "sigDeadline",
											"type": "uint256"
										}
									],
									"internalType": "struct IPermit2.PermitSingle",
									"name": "permitSingle",
									"type": "tuple"
								},
								{
									"internalType": "bytes",
									"name": "signature",
									"type": "bytes"
								}
							],
							"name": "permit",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "user",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint160",
									"name": "amount",
									"type": "uint160"
								},
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								}
							],
							"name": "transferFrom",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"details": "Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.",
						"kind": "dev",
						"methods": {
							"allowance(address,address,address)": {
								"params": {
									"spender": "The spender's address.",
									"token": "The token address.",
									"user": "The token owner's address."
								},
								"returns": {
									"_0": "The packed allowance details."
								}
							},
							"approve(address,address,uint160,uint48)": {
								"details": "The packed allowance also holds a nonce, which will stay unchanged in approveSetting amount to type(uint160).max sets an unlimited approval",
								"params": {
									"amount": "The approved amount of the token",
									"expiration": "The timestamp at which the approval is no longer valid",
									"spender": "The spender address to approve",
									"token": "The token to approve"
								}
							},
							"permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)": {
								"params": {
									"owner": "The token owner's address.",
									"permitSingle": "Struct containing the permit details.",
									"signature": "The signature proving the owner authorized the permit."
								}
							},
							"transferFrom(address,address,uint160,address)": {
								"params": {
									"amount": "The amount of tokens to transfer.",
									"spender": "The address authorized to spend the tokens.",
									"token": "The address of the token being transferred.",
									"user": "The token owner's address."
								}
							}
						},
						"title": "IPermit2",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"amount\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"}],\"internalType\":\"struct IPermit2.PackedAllowance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amount\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amount\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"}],\"internalType\":\"struct IPermit2.PermitDetails\",\"name\":\"details\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sigDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IPermit2.PermitSingle\",\"name\":\"permitSingle\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amount\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\",\"kind\":\"dev\",\"methods\":{\"allowance(address,address,address)\":{\"params\":{\"spender\":\"The spender's address.\",\"token\":\"The token address.\",\"user\":\"The token owner's address.\"},\"returns\":{\"_0\":\"The packed allowance details.\"}},\"approve(address,address,uint160,uint48)\":{\"details\":\"The packed allowance also holds a nonce, which will stay unchanged in approveSetting amount to type(uint160).max sets an unlimited approval\",\"params\":{\"amount\":\"The approved amount of the token\",\"expiration\":\"The timestamp at which the approval is no longer valid\",\"spender\":\"The spender address to approve\",\"token\":\"The token to approve\"}},\"permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)\":{\"params\":{\"owner\":\"The token owner's address.\",\"permitSingle\":\"Struct containing the permit details.\",\"signature\":\"The signature proving the owner authorized the permit.\"}},\"transferFrom(address,address,uint160,address)\":{\"params\":{\"amount\":\"The amount of tokens to transfer.\",\"spender\":\"The address authorized to spend the tokens.\",\"token\":\"The address of the token being transferred.\",\"user\":\"The token owner's address.\"}}},\"title\":\"IPermit2\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allowance(address,address,address)\":{\"notice\":\"Retrieves the allowance details between a token owner and spender.\"},\"approve(address,address,uint160,uint48)\":{\"notice\":\"Approves the spender to use up to amount of the specified token up until the expiration\"},\"permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)\":{\"notice\":\"Issues a permit for spending tokens via a signed authorization.\"},\"transferFrom(address,address,uint160,address)\":{\"notice\":\"Executes a token transfer from one address to another.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IPermit2.sol\":\"IPermit2\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IPermit2.sol\":{\"keccak256\":\"0x79e985eddaf616078cde10431fb615b577ba83b96ca5f4161cb82939a787a195\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a1d3243656736b7e4422a6eb7bbac982760f99674b9d80286e5bf45f1fe04376\",\"dweb:/ipfs/QmacX52RVqLnUgWxji9FkfFSZeGnV6qdxkkX5kMxakYRyW\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {
							"allowance(address,address,address)": {
								"notice": "Retrieves the allowance details between a token owner and spender."
							},
							"approve(address,address,uint160,uint48)": {
								"notice": "Approves the spender to use up to amount of the specified token up until the expiration"
							},
							"permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)": {
								"notice": "Issues a permit for spending tokens via a signed authorization."
							},
							"transferFrom(address,address,uint160,address)": {
								"notice": "Executes a token transfer from one address to another."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/IWETH.sol": {
				"IWETH": {
					"abi": [
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "Approval",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "dst",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "wad",
									"type": "uint256"
								}
							],
							"name": "Deposit",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "from",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "to",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "Transfer",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "src",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "wad",
									"type": "uint256"
								}
							],
							"name": "Withdrawal",
							"type": "event"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								}
							],
							"name": "allowance",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "spender",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "approve",
							"outputs": [
								{
									"internalType": "bool",
									"name": "",
									"type": "bool"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "account",
									"type": "address"
								}
							],
							"name": "balanceOf",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "deposit",
							"outputs": [],
							"stateMutability": "payable",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "totalSupply",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "to",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "transfer",
							"outputs": [
								{
									"internalType": "bool",
									"name": "",
									"type": "bool"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "from",
									"type": "address"
								},
								{
									"internalType": "address",
									"name": "to",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "value",
									"type": "uint256"
								}
							],
							"name": "transferFrom",
							"outputs": [
								{
									"internalType": "bool",
									"name": "",
									"type": "bool"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"details": "Interface for wrapper as WETH-like token.",
						"events": {
							"Approval(address,address,uint256)": {
								"details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
							},
							"Transfer(address,address,uint256)": {
								"details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
							}
						},
						"kind": "dev",
						"methods": {
							"allowance(address,address)": {
								"details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
							},
							"approve(address,uint256)": {
								"details": "Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
							},
							"balanceOf(address)": {
								"details": "Returns the value of tokens owned by `account`."
							},
							"totalSupply()": {
								"details": "Returns the value of tokens in existence."
							},
							"transfer(address,uint256)": {
								"details": "Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
							},
							"transferFrom(address,address,uint256)": {
								"details": "Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
							},
							"withdraw(uint256)": {
								"params": {
									"amount": "Amount of wrapped tokens to withdraw."
								}
							}
						},
						"title": "IWETH",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface for wrapper as WETH-like token.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the value of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the value of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"withdraw(uint256)\":{\"params\":{\"amount\":\"Amount of wrapped tokens to withdraw.\"}}},\"title\":\"IWETH\",\"version\":1},\"userdoc\":{\"events\":{\"Deposit(address,uint256)\":{\"notice\":\"Emitted when Ether is deposited to get wrapper tokens.\"},\"Withdrawal(address,uint256)\":{\"notice\":\"Emitted when wrapper tokens is withdrawn as Ether.\"}},\"kind\":\"user\",\"methods\":{\"deposit()\":{\"notice\":\"Deposit Ether to get wrapper tokens.\"},\"withdraw(uint256)\":{\"notice\":\"Withdraw wrapped tokens as Ether.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IWETH.sol\":\"IWETH\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IERC20.sol\":{\"keccak256\":\"0x91104f4bcc877f2506e4485b871efe0a6beb5c1ef7de9c374d99d75289905905\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://57a7ecbec5ff542c117d36c7487386b5653ad21d0a83414e859d4202e069b36f\",\"dweb:/ipfs/QmaPocSUaysdjd1Ksa5kttxRHxhA7XWd6HrQ9teLFRyR6W\"]},\"contracts/IWETH.sol\":{\"keccak256\":\"0x2dc6d61d66f1881a6c273b5f30f9a82e6eda4988c7aeaf0b26549a5e10c9fcb9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1695d9fd49960e732d2228a304fe9bc221439293e940fdcb9c17419ccafdcfc1\",\"dweb:/ipfs/QmPZrdz4icyWQeR5Yf1zDQnpH8MmYiHyKofVcwvwNADjRh\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"Deposit(address,uint256)": {
								"notice": "Emitted when Ether is deposited to get wrapper tokens."
							},
							"Withdrawal(address,uint256)": {
								"notice": "Emitted when wrapper tokens is withdrawn as Ether."
							}
						},
						"kind": "user",
						"methods": {
							"deposit()": {
								"notice": "Deposit Ether to get wrapper tokens."
							},
							"withdraw(uint256)": {
								"notice": "Withdraw wrapped tokens as Ether."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/RevertReasonForwarder.sol": {
				"RevertReasonForwarder": {
					"abi": [],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"title": "RevertReasonForwarder",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220f231314aa3aea6a5b7c0be07924e2127d4641a8c1c5f097d10db6fadc6c288e064736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 CALLCODE BALANCE BALANCE 0x4A LOG3 0xAE 0xA6 0xA5 0xB7 0xC0 0xBE SMOD SWAP3 0x4E 0x21 0x27 0xD4 PUSH5 0x1A8C1C5F09 PUSH30 0x10DB6FADC6C288E064736F6C634300081700330000000000000000000000 ",
							"sourceMap": "201:1192:8:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea2646970667358221220f231314aa3aea6a5b7c0be07924e2127d4641a8c1c5f097d10db6fadc6c288e064736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 CALLCODE BALANCE BALANCE 0x4A LOG3 0xAE 0xA6 0xA5 0xB7 0xC0 0xBE SMOD SWAP3 0x4E 0x21 0x27 0xD4 PUSH5 0x1A8C1C5F09 PUSH30 0x10DB6FADC6C288E064736F6C634300081700330000000000000000000000 ",
							"sourceMap": "201:1192:8:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"RevertReasonForwarder\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Provides utilities for forwarding and retrieving revert reasons from failed external calls.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RevertReasonForwarder.sol\":\"RevertReasonForwarder\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/RevertReasonForwarder.sol\":{\"keccak256\":\"0x00dbd12fec0c2696dd0862143457d8a23c998dcabd5d038fc85512ba93467417\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2fa738dc80ff7027762294869f2b181177a5c122fe04ceea08c619c544c820aa\",\"dweb:/ipfs/QmUzrDWe6k6Hhfdd5MxUhnW34B8mGJ5pwx65NM9EBLkLCU\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"notice": "Provides utilities for forwarding and retrieving revert reasons from failed external calls.",
						"version": 1
					}
				}
			},
			"contracts/SafeERC20.sol": {
				"SafeERC20": {
					"abi": [
						{
							"inputs": [],
							"name": "ForceApproveFailed",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "Permit2TransferAmountTooHigh",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeDecreaseAllowanceFailed",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeIncreaseAllowanceFailed",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafePermitBadLength",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeTransferFailed",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeTransferFromFailed",
							"type": "error"
						}
					],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"title": "Implements efficient safe methods for ERC20 interface.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212203eb2c095b16948e2d5b1f29424dfe257bf5a994bcfa0663a349159d8b1cf12cd64736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 RETURNDATACOPY 0xB2 0xC0 SWAP6 0xB1 PUSH10 0x48E2D5B1F29424DFE257 0xBF GAS SWAP10 0x4B 0xCF LOG0 PUSH7 0x3A349159D8B1CF SLT 0xCD PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "629:26209:9:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea26469706673582212203eb2c095b16948e2d5b1f29424dfe257bf5a994bcfa0663a349159d8b1cf12cd64736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 RETURNDATACOPY 0xB2 0xC0 SWAP6 0xB1 PUSH10 0x48E2D5B1F29424DFE257 0xBF GAS SWAP10 0x4B 0xCF LOG0 PUSH7 0x3A349159D8B1CF SLT 0xCD PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "629:26209:9:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ForceApproveFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Permit2TransferAmountTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeDecreaseAllowanceFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeIncreaseAllowanceFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafePermitBadLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromFailed\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"Implements efficient safe methods for ERC20 interface.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Compared to the standard ERC20, this implementation offers several enhancements: 1. more gas-efficient, providing significant savings in transaction costs. 2. support for different permit implementations 3. forceApprove functionality 4. support for WETH deposit and withdraw\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SafeERC20.sol\":\"SafeERC20\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/IDaiLikePermit.sol\":{\"keccak256\":\"0x0bcc9c886acb32f5664e3bfd0640e6fc1de6525b8f6103f25906d040d054ce07\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://551e3b7d18d5e83727491f6749643a9a1e9a2e253a1a9be56eeb44e4c1b13876\",\"dweb:/ipfs/QmSpGRSD3DDP1EbBbXDPqAbSP58roEvCsosMQCDtSDnEBa\"]},\"contracts/IERC20.sol\":{\"keccak256\":\"0x91104f4bcc877f2506e4485b871efe0a6beb5c1ef7de9c374d99d75289905905\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://57a7ecbec5ff542c117d36c7487386b5653ad21d0a83414e859d4202e069b36f\",\"dweb:/ipfs/QmaPocSUaysdjd1Ksa5kttxRHxhA7XWd6HrQ9teLFRyR6W\"]},\"contracts/IERC20Permit.sol\":{\"keccak256\":\"0x08d82b52e80c1a83f792c519388ca1ae86ae441bdfbd7d84addc82ef9c499a9e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a5449dde3b5541f3f653b352bfa0aa4f3e91ab24a110106319baa83940f540a5\",\"dweb:/ipfs/QmUuadcLdSPtqMuuhBgkdAZHrE3tx5rdQ7HCXCsa8RDaTU\"]},\"contracts/IERC7597Permit.sol\":{\"keccak256\":\"0x550ff037524afe9ef46d2c54ed59f4048c4216122e80da3b17872e05c163a74e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://40df00df81d4a4d2a78105bf5b86694037d885abf30e1e47e286b6e3310bdf48\",\"dweb:/ipfs/QmVqmS8BpSMV8PeiUme1tNDq48zfn71XYxWhb6fLtxCT6f\"]},\"contracts/IPermit2.sol\":{\"keccak256\":\"0x79e985eddaf616078cde10431fb615b577ba83b96ca5f4161cb82939a787a195\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a1d3243656736b7e4422a6eb7bbac982760f99674b9d80286e5bf45f1fe04376\",\"dweb:/ipfs/QmacX52RVqLnUgWxji9FkfFSZeGnV6qdxkkX5kMxakYRyW\"]},\"contracts/IWETH.sol\":{\"keccak256\":\"0x2dc6d61d66f1881a6c273b5f30f9a82e6eda4988c7aeaf0b26549a5e10c9fcb9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1695d9fd49960e732d2228a304fe9bc221439293e940fdcb9c17419ccafdcfc1\",\"dweb:/ipfs/QmPZrdz4icyWQeR5Yf1zDQnpH8MmYiHyKofVcwvwNADjRh\"]},\"contracts/RevertReasonForwarder.sol\":{\"keccak256\":\"0x00dbd12fec0c2696dd0862143457d8a23c998dcabd5d038fc85512ba93467417\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2fa738dc80ff7027762294869f2b181177a5c122fe04ceea08c619c544c820aa\",\"dweb:/ipfs/QmUzrDWe6k6Hhfdd5MxUhnW34B8mGJ5pwx65NM9EBLkLCU\"]},\"contracts/SafeERC20.sol\":{\"keccak256\":\"0x2cdc46994aa3302bf2026f5a2ba0650398aaf41278354075544bf42350ee947e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6a65e24d410030f7b192d59a0096213bee88b963822052502572cdb9ee55e9d9\",\"dweb:/ipfs/QmcQH7uVFhTLGxTuqUsiEsc7qH9HE7xGgSQTXijoVUcKUn\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"notice": "Compared to the standard ERC20, this implementation offers several enhancements: 1. more gas-efficient, providing significant savings in transaction costs. 2. support for different permit implementations 3. forceApprove functionality 4. support for WETH deposit and withdraw",
						"version": 1
					}
				}
			},
			"contracts/escrow/BaseEscrow.sol": {
				"BaseEscrow": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidCaller",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidImmutables",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidSecret",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidTime",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "NativeTokenSendingFailure",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeTransferFailed",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [],
							"name": "EscrowCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								}
							],
							"name": "EscrowWithdrawal",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "FundsRescued",
							"type": "event"
						},
						{
							"inputs": [],
							"name": "FACTORY",
							"outputs": [
								{
									"internalType": "address",
									"name": "",
									"type": "address"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "RESCUE_DELAY",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "cancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "rescueFunds",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"details": "{IBaseEscrow-withdraw}, {IBaseEscrow-cancel} and _validateImmutables functions must be implemented in the derived contracts.",
						"events": {
							"EscrowWithdrawal(bytes32)": {
								"params": {
									"secret": "The secret that unlocks the escrow."
								}
							},
							"FundsRescued(address,uint256)": {
								"params": {
									"amount": "The amount of tokens rescued.",
									"token": "The address of the token rescued. Zero address for native token."
								}
							}
						},
						"kind": "dev",
						"methods": {
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract."
								}
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow."
								}
							}
						},
						"title": "Base abstract Escrow contract for cross-chain atomic swap.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImmutables\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecret\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenSendingFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"EscrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"details\":\"{IBaseEscrow-withdraw}, {IBaseEscrow-cancel} and _validateImmutables functions must be implemented in the derived contracts.\",\"events\":{\"EscrowWithdrawal(bytes32)\":{\"params\":{\"secret\":\"The secret that unlocks the escrow.\"}},\"FundsRescued(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens rescued.\",\"token\":\"The address of the token rescued. Zero address for native token.\"}}},\"kind\":\"dev\",\"methods\":{\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\"}},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\"}}},\"title\":\"Base abstract Escrow contract for cross-chain atomic swap.\",\"version\":1},\"userdoc\":{\"events\":{\"EscrowCancelled()\":{\"notice\":\"Emitted on escrow cancellation.\"},\"EscrowWithdrawal(bytes32)\":{\"notice\":\"Emitted on successful withdrawal.\"},\"FundsRescued(address,uint256)\":{\"notice\":\"Emitted when funds are rescued.\"}},\"kind\":\"user\",\"methods\":{\"FACTORY()\":{\"notice\":\"See {IBaseEscrow-FACTORY}.\"},\"RESCUE_DELAY()\":{\"notice\":\"See {IBaseEscrow-RESCUE_DELAY}.\"},\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Cancels the escrow and returns tokens to a predetermined recipient.\"},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IBaseEscrow-rescueFunds}.\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to a predetermined recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/BaseEscrow.sol\":\"BaseEscrow\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/IDaiLikePermit.sol\":{\"keccak256\":\"0x0bcc9c886acb32f5664e3bfd0640e6fc1de6525b8f6103f25906d040d054ce07\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://551e3b7d18d5e83727491f6749643a9a1e9a2e253a1a9be56eeb44e4c1b13876\",\"dweb:/ipfs/QmSpGRSD3DDP1EbBbXDPqAbSP58roEvCsosMQCDtSDnEBa\"]},\"contracts/IERC20.sol\":{\"keccak256\":\"0x91104f4bcc877f2506e4485b871efe0a6beb5c1ef7de9c374d99d75289905905\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://57a7ecbec5ff542c117d36c7487386b5653ad21d0a83414e859d4202e069b36f\",\"dweb:/ipfs/QmaPocSUaysdjd1Ksa5kttxRHxhA7XWd6HrQ9teLFRyR6W\"]},\"contracts/IERC20Permit.sol\":{\"keccak256\":\"0x08d82b52e80c1a83f792c519388ca1ae86ae441bdfbd7d84addc82ef9c499a9e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a5449dde3b5541f3f653b352bfa0aa4f3e91ab24a110106319baa83940f540a5\",\"dweb:/ipfs/QmUuadcLdSPtqMuuhBgkdAZHrE3tx5rdQ7HCXCsa8RDaTU\"]},\"contracts/IERC7597Permit.sol\":{\"keccak256\":\"0x550ff037524afe9ef46d2c54ed59f4048c4216122e80da3b17872e05c163a74e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://40df00df81d4a4d2a78105bf5b86694037d885abf30e1e47e286b6e3310bdf48\",\"dweb:/ipfs/QmVqmS8BpSMV8PeiUme1tNDq48zfn71XYxWhb6fLtxCT6f\"]},\"contracts/IPermit2.sol\":{\"keccak256\":\"0x79e985eddaf616078cde10431fb615b577ba83b96ca5f4161cb82939a787a195\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a1d3243656736b7e4422a6eb7bbac982760f99674b9d80286e5bf45f1fe04376\",\"dweb:/ipfs/QmacX52RVqLnUgWxji9FkfFSZeGnV6qdxkkX5kMxakYRyW\"]},\"contracts/IWETH.sol\":{\"keccak256\":\"0x2dc6d61d66f1881a6c273b5f30f9a82e6eda4988c7aeaf0b26549a5e10c9fcb9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1695d9fd49960e732d2228a304fe9bc221439293e940fdcb9c17419ccafdcfc1\",\"dweb:/ipfs/QmPZrdz4icyWQeR5Yf1zDQnpH8MmYiHyKofVcwvwNADjRh\"]},\"contracts/RevertReasonForwarder.sol\":{\"keccak256\":\"0x00dbd12fec0c2696dd0862143457d8a23c998dcabd5d038fc85512ba93467417\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2fa738dc80ff7027762294869f2b181177a5c122fe04ceea08c619c544c820aa\",\"dweb:/ipfs/QmUzrDWe6k6Hhfdd5MxUhnW34B8mGJ5pwx65NM9EBLkLCU\"]},\"contracts/SafeERC20.sol\":{\"keccak256\":\"0x2cdc46994aa3302bf2026f5a2ba0650398aaf41278354075544bf42350ee947e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6a65e24d410030f7b192d59a0096213bee88b963822052502572cdb9ee55e9d9\",\"dweb:/ipfs/QmcQH7uVFhTLGxTuqUsiEsc7qH9HE7xGgSQTXijoVUcKUn\"]},\"contracts/escrow/BaseEscrow.sol\":{\"keccak256\":\"0x1436c940fcfbeb3c3248055e1b50184f41df8108362ff40db0183814c6311d89\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://635dbe2acc93061e09b7db75dafe8bb9ae6f72dd6901cd304015869f1cdbe4b8\",\"dweb:/ipfs/QmZ6jF22Liy5tERu5faTNdhXgsUSTdv5xsB3bmaDZiHJiK\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/libraries/ImmutablesLib.sol\":{\"keccak256\":\"0x61b4a772ba17cbb1e52d09c71903d694a6f032c7c3bff76ba109a2d2b606fcca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fdb8ddefa42e86bc8456c01bada27d8d68e52a64c1f117fc939df6052ca9f93b\",\"dweb:/ipfs/QmciZYyGkJHxsoDQHGnXYCf9R6eKpHz88L161MMiozTvwH\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"EscrowCancelled()": {
								"notice": "Emitted on escrow cancellation."
							},
							"EscrowWithdrawal(bytes32)": {
								"notice": "Emitted on successful withdrawal."
							},
							"FundsRescued(address,uint256)": {
								"notice": "Emitted when funds are rescued."
							}
						},
						"kind": "user",
						"methods": {
							"FACTORY()": {
								"notice": "See {IBaseEscrow-FACTORY}."
							},
							"RESCUE_DELAY()": {
								"notice": "See {IBaseEscrow-RESCUE_DELAY}."
							},
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Cancels the escrow and returns tokens to a predetermined recipient."
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IBaseEscrow-rescueFunds}."
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to a predetermined recipient."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/escrow/Create2.sol": {
				"Create2": {
					"abi": [
						{
							"inputs": [],
							"name": "Create2EmptyBytecode",
							"type": "error"
						}
					],
					"devdoc": {
						"details": "Helper to make usage of the `CREATE2` EVM opcode easier and safer. `CREATE2` can be used to compute in advance the address where a smart contract will be deployed, which allows for interesting new mechanisms known as 'counterfactual interactions'. See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more information.",
						"errors": {
							"Create2EmptyBytecode()": [
								{
									"details": "There's no code to deploy."
								}
							]
						},
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212201cdc0ef101eca073db56b73498a9d47f7a56ec74366338ab3b6de3b729998ff464736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SHR 0xDC 0xE CALL ADD 0xEC LOG0 PUSH20 0xDB56B73498A9D47F7A56EC74366338AB3B6DE3B7 0x29 SWAP10 DUP16 DELEGATECALL PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "534:3685:11:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea26469706673582212201cdc0ef101eca073db56b73498a9d47f7a56ec74366338ab3b6de3b729998ff464736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SHR 0xDC 0xE CALL ADD 0xEC LOG0 PUSH20 0xDB56B73498A9D47F7A56EC74366338AB3B6DE3B7 0x29 SWAP10 DUP16 DELEGATECALL PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "534:3685:11:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"Create2EmptyBytecode\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Helper to make usage of the `CREATE2` EVM opcode easier and safer. `CREATE2` can be used to compute in advance the address where a smart contract will be deployed, which allows for interesting new mechanisms known as 'counterfactual interactions'. See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more information.\",\"errors\":{\"Create2EmptyBytecode()\":[{\"details\":\"There's no code to deploy.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/Create2.sol\":\"Create2\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/Errors.sol\":{\"keccak256\":\"0x1b0625096e82d06abdcf1844172ef78ef54a5e878761f4d905fda07eaf098424\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5cd99f1a4836c07461cb3ea023ae2f6d1d01e80694b764a87623aa7252754756\",\"dweb:/ipfs/QmNPNDuiNU6TJatZcdBcrwixBoo5MSXNDq4kaXhpJLWGpB\"]},\"contracts/escrow/Create2.sol\":{\"keccak256\":\"0x02f0faa500d9ca42186fd2f4d7f381777cd2970bfa2fd7fb542c309361aae81c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5f45127145cf2abd405d732ccaeaf467d853a3779bc85e090133e6005d197a4\",\"dweb:/ipfs/Qmdg1VaKkAWQ1qcVWYr9cRuoeGhg2QvrJPyDukyR7dwf8d\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"contracts/escrow/Escrow.sol": {
				"Escrow": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidCaller",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidImmutables",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidSecret",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidTime",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "NativeTokenSendingFailure",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeTransferFailed",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [],
							"name": "EscrowCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								}
							],
							"name": "EscrowWithdrawal",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "FundsRescued",
							"type": "event"
						},
						{
							"inputs": [],
							"name": "FACTORY",
							"outputs": [
								{
									"internalType": "address",
									"name": "",
									"type": "address"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "PROXY_BYTECODE_HASH",
							"outputs": [
								{
									"internalType": "bytes32",
									"name": "",
									"type": "bytes32"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "RESCUE_DELAY",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "cancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "rescueFunds",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"details": "{IBaseEscrow-withdraw} and {IBaseEscrow-cancel} functions must be implemented in the derived contracts.",
						"events": {
							"EscrowWithdrawal(bytes32)": {
								"params": {
									"secret": "The secret that unlocks the escrow."
								}
							},
							"FundsRescued(address,uint256)": {
								"params": {
									"amount": "The amount of tokens rescued.",
									"token": "The address of the token rescued. Zero address for native token."
								}
							}
						},
						"kind": "dev",
						"methods": {
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract."
								}
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow."
								}
							}
						},
						"title": "Abstract Escrow contract for cross-chain atomic swap.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImmutables\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecret\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenSendingFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"EscrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROXY_BYTECODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"details\":\"{IBaseEscrow-withdraw} and {IBaseEscrow-cancel} functions must be implemented in the derived contracts.\",\"events\":{\"EscrowWithdrawal(bytes32)\":{\"params\":{\"secret\":\"The secret that unlocks the escrow.\"}},\"FundsRescued(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens rescued.\",\"token\":\"The address of the token rescued. Zero address for native token.\"}}},\"kind\":\"dev\",\"methods\":{\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\"}},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\"}}},\"title\":\"Abstract Escrow contract for cross-chain atomic swap.\",\"version\":1},\"userdoc\":{\"events\":{\"EscrowCancelled()\":{\"notice\":\"Emitted on escrow cancellation.\"},\"EscrowWithdrawal(bytes32)\":{\"notice\":\"Emitted on successful withdrawal.\"},\"FundsRescued(address,uint256)\":{\"notice\":\"Emitted when funds are rescued.\"}},\"kind\":\"user\",\"methods\":{\"FACTORY()\":{\"notice\":\"See {IBaseEscrow-FACTORY}.\"},\"PROXY_BYTECODE_HASH()\":{\"notice\":\"See {IEscrow-PROXY_BYTECODE_HASH}.\"},\"RESCUE_DELAY()\":{\"notice\":\"See {IBaseEscrow-RESCUE_DELAY}.\"},\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Cancels the escrow and returns tokens to a predetermined recipient.\"},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IBaseEscrow-rescueFunds}.\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to a predetermined recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/Escrow.sol\":\"Escrow\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/Errors.sol\":{\"keccak256\":\"0x1b0625096e82d06abdcf1844172ef78ef54a5e878761f4d905fda07eaf098424\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5cd99f1a4836c07461cb3ea023ae2f6d1d01e80694b764a87623aa7252754756\",\"dweb:/ipfs/QmNPNDuiNU6TJatZcdBcrwixBoo5MSXNDq4kaXhpJLWGpB\"]},\"contracts/IDaiLikePermit.sol\":{\"keccak256\":\"0x0bcc9c886acb32f5664e3bfd0640e6fc1de6525b8f6103f25906d040d054ce07\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://551e3b7d18d5e83727491f6749643a9a1e9a2e253a1a9be56eeb44e4c1b13876\",\"dweb:/ipfs/QmSpGRSD3DDP1EbBbXDPqAbSP58roEvCsosMQCDtSDnEBa\"]},\"contracts/IERC20.sol\":{\"keccak256\":\"0x91104f4bcc877f2506e4485b871efe0a6beb5c1ef7de9c374d99d75289905905\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://57a7ecbec5ff542c117d36c7487386b5653ad21d0a83414e859d4202e069b36f\",\"dweb:/ipfs/QmaPocSUaysdjd1Ksa5kttxRHxhA7XWd6HrQ9teLFRyR6W\"]},\"contracts/IERC20Permit.sol\":{\"keccak256\":\"0x08d82b52e80c1a83f792c519388ca1ae86ae441bdfbd7d84addc82ef9c499a9e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a5449dde3b5541f3f653b352bfa0aa4f3e91ab24a110106319baa83940f540a5\",\"dweb:/ipfs/QmUuadcLdSPtqMuuhBgkdAZHrE3tx5rdQ7HCXCsa8RDaTU\"]},\"contracts/IERC7597Permit.sol\":{\"keccak256\":\"0x550ff037524afe9ef46d2c54ed59f4048c4216122e80da3b17872e05c163a74e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://40df00df81d4a4d2a78105bf5b86694037d885abf30e1e47e286b6e3310bdf48\",\"dweb:/ipfs/QmVqmS8BpSMV8PeiUme1tNDq48zfn71XYxWhb6fLtxCT6f\"]},\"contracts/IPermit2.sol\":{\"keccak256\":\"0x79e985eddaf616078cde10431fb615b577ba83b96ca5f4161cb82939a787a195\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a1d3243656736b7e4422a6eb7bbac982760f99674b9d80286e5bf45f1fe04376\",\"dweb:/ipfs/QmacX52RVqLnUgWxji9FkfFSZeGnV6qdxkkX5kMxakYRyW\"]},\"contracts/IWETH.sol\":{\"keccak256\":\"0x2dc6d61d66f1881a6c273b5f30f9a82e6eda4988c7aeaf0b26549a5e10c9fcb9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1695d9fd49960e732d2228a304fe9bc221439293e940fdcb9c17419ccafdcfc1\",\"dweb:/ipfs/QmPZrdz4icyWQeR5Yf1zDQnpH8MmYiHyKofVcwvwNADjRh\"]},\"contracts/RevertReasonForwarder.sol\":{\"keccak256\":\"0x00dbd12fec0c2696dd0862143457d8a23c998dcabd5d038fc85512ba93467417\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2fa738dc80ff7027762294869f2b181177a5c122fe04ceea08c619c544c820aa\",\"dweb:/ipfs/QmUzrDWe6k6Hhfdd5MxUhnW34B8mGJ5pwx65NM9EBLkLCU\"]},\"contracts/SafeERC20.sol\":{\"keccak256\":\"0x2cdc46994aa3302bf2026f5a2ba0650398aaf41278354075544bf42350ee947e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6a65e24d410030f7b192d59a0096213bee88b963822052502572cdb9ee55e9d9\",\"dweb:/ipfs/QmcQH7uVFhTLGxTuqUsiEsc7qH9HE7xGgSQTXijoVUcKUn\"]},\"contracts/escrow/BaseEscrow.sol\":{\"keccak256\":\"0x1436c940fcfbeb3c3248055e1b50184f41df8108362ff40db0183814c6311d89\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://635dbe2acc93061e09b7db75dafe8bb9ae6f72dd6901cd304015869f1cdbe4b8\",\"dweb:/ipfs/QmZ6jF22Liy5tERu5faTNdhXgsUSTdv5xsB3bmaDZiHJiK\"]},\"contracts/escrow/Create2.sol\":{\"keccak256\":\"0x02f0faa500d9ca42186fd2f4d7f381777cd2970bfa2fd7fb542c309361aae81c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5f45127145cf2abd405d732ccaeaf467d853a3779bc85e090133e6005d197a4\",\"dweb:/ipfs/Qmdg1VaKkAWQ1qcVWYr9cRuoeGhg2QvrJPyDukyR7dwf8d\"]},\"contracts/escrow/Escrow.sol\":{\"keccak256\":\"0x718d6ffede1758a543b6d76f329130015f8af696e17178d5661c81b35d9f9839\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8e910017a35b6888d255e2791790c192a588b41c6d2b9c239199c0c2317add84\",\"dweb:/ipfs/QmXKnin4x6MPWeyTgxiLzvWj11NxxAEcu7JGzjUoGETb1g\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/interfaces/IEscrow.sol\":{\"keccak256\":\"0x8b0063cd06290dfc5d4bb20a9bdddff356f3100bd63d5a0c3f1b8d30d028fc10\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://78e81dc1ba169a0f328efc4824192f8906189e3cb2ed263543ecd1f9a61b7ac6\",\"dweb:/ipfs/QmeaB5ymsLYZhUXrt4TFW6qYBPgLgUMEoAhggqAscZ2pNq\"]},\"contracts/escrow/libraries/ImmutablesLib.sol\":{\"keccak256\":\"0x61b4a772ba17cbb1e52d09c71903d694a6f032c7c3bff76ba109a2d2b606fcca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fdb8ddefa42e86bc8456c01bada27d8d68e52a64c1f117fc939df6052ca9f93b\",\"dweb:/ipfs/QmciZYyGkJHxsoDQHGnXYCf9R6eKpHz88L161MMiozTvwH\"]},\"contracts/escrow/libraries/ProxyHashLib.sol\":{\"keccak256\":\"0x9e899d11aa1548e1f30a61ad87668b0dfd2b3464fbc1abef8ec95352c8c34c0d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://69ec0c4598b490cb0146872af15dd06e490db823efb3e60c6d500e62deb49689\",\"dweb:/ipfs/QmdfEwW8nzfHN9HpDRh8DKR2LrVWLXpJrig28aHhFkNUp3\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"EscrowCancelled()": {
								"notice": "Emitted on escrow cancellation."
							},
							"EscrowWithdrawal(bytes32)": {
								"notice": "Emitted on successful withdrawal."
							},
							"FundsRescued(address,uint256)": {
								"notice": "Emitted when funds are rescued."
							}
						},
						"kind": "user",
						"methods": {
							"FACTORY()": {
								"notice": "See {IBaseEscrow-FACTORY}."
							},
							"PROXY_BYTECODE_HASH()": {
								"notice": "See {IEscrow-PROXY_BYTECODE_HASH}."
							},
							"RESCUE_DELAY()": {
								"notice": "See {IBaseEscrow-RESCUE_DELAY}."
							},
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Cancels the escrow and returns tokens to a predetermined recipient."
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IBaseEscrow-rescueFunds}."
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to a predetermined recipient."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/escrow/EscrowSrc.sol": {
				"EscrowSrc": {
					"abi": [
						{
							"inputs": [
								{
									"internalType": "uint32",
									"name": "rescueDelay",
									"type": "uint32"
								},
								{
									"internalType": "contract IERC20",
									"name": "accessToken",
									"type": "address"
								}
							],
							"stateMutability": "nonpayable",
							"type": "constructor"
						},
						{
							"inputs": [],
							"name": "InvalidCaller",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidImmutables",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidSecret",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidTime",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "NativeTokenSendingFailure",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "SafeTransferFailed",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [],
							"name": "EscrowCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								}
							],
							"name": "EscrowWithdrawal",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "FundsRescued",
							"type": "event"
						},
						{
							"inputs": [],
							"name": "FACTORY",
							"outputs": [
								{
									"internalType": "address",
									"name": "",
									"type": "address"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "PROXY_BYTECODE_HASH",
							"outputs": [
								{
									"internalType": "bytes32",
									"name": "",
									"type": "bytes32"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "RESCUE_DELAY",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "cancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "publicCancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "publicWithdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "rescueFunds",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"internalType": "address",
									"name": "target",
									"type": "address"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdrawTo",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"details": "Funds are locked in at the time of contract deployment. For this Limit Order Protocol calls the `EscrowFactory.postInteraction` function. To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.",
						"events": {
							"EscrowWithdrawal(bytes32)": {
								"params": {
									"secret": "The secret that unlocks the escrow."
								}
							},
							"FundsRescued(address,uint256)": {
								"params": {
									"amount": "The amount of tokens rescued.",
									"token": "The address of the token rescued. Zero address for native token."
								}
							}
						},
						"kind": "dev",
						"methods": {
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The function works on the time intervals highlighted with capital letters: ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/-- --/-- PRIVATE CANCELLATION --/-- PUBLIC CANCELLATION ----"
							},
							"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The function works on the time intervals highlighted with capital letters: ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/-- --/-- private cancellation --/-- PUBLIC CANCELLATION ----"
							},
							"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The function works on the time interval highlighted with capital letters: ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/-- --/-- private cancellation --/-- public cancellation ----"
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The function works on the time interval highlighted with capital letters: ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/-- --/-- private cancellation --/-- public cancellation ----"
							},
							"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The function works on the time interval highlighted with capital letters: ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/-- --/-- private cancellation --/-- public cancellation ----"
							}
						},
						"title": "Source Escrow contract for cross-chain atomic swap.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6101003461011557601f610b4f38819003918201601f19168301916001600160401b038311848410176101195780849260409485528339810103126101155780519063ffffffff82168092036101155760200151906001600160a01b0382168203610115573360c05260a0526080526e5af43d82803e903d91602b57fd5bf360205230601152763d602d80600a3d3981f3363d3d373d3d3d363d730000003060881c175f52603760092060e052604051610a21908161012e823960805181818160f801526105bf015260a051818181609b01526103b8015260c05181818161049a015281816107e40152818161087101526108eb015260e051818181610463015281816107b90152818161084601526108c00152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080604090808252600480361015610015575f80fd5b60e05f35811c9283630af97558146105875750826323305703146104c95782632dd310001461048657826334862b6a1461044c5782634649088b146103635782636c10c0c81461026157826390d3252f1461020d578263daff233e146100c257505063f56cd69c14610085575f80fd5b346100be575f3660031901126100be57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5f80fd5b83346100be576101003660031901126100be5780516370a0823160e01b815233848201526001600160a01b0392906020816024817f000000000000000000000000000000000000000000000000000000000000000088165afa908115610203575f916101d1575b50156101c15763ffffffff60e43580921c9160601c1681018091116101ae57421061019f5761016d8261015a610831565b60a4359080604435169060843516610926565b61017960c4353361098d565b7f6e3be9294e58d10b9c8053cfd5e09871b67e442fe394d6b0870d336b9df984a95f80a1005b516337bf561360e11b81529050fd5b601184634e487b7160e01b5f525260245ffd5b81516348f5c3ed60e01b81528490fd5b90506020813d6020116101fb575b816101ec60209383610729565b810103126100be575185610129565b3d91506101df565b83513d5f823e3d90fd5b5082346100be576101003660031901126100be576001600160a01b0390606435821633036102525761024060e43561075f565b421061019f5761016d8261015a610831565b516348f5c3ed60e01b81529050fd5b5082346100be576101403660031901126100be578135916001600160a01b03906024359082821682036100be576101003660431901126100be578260a43516330361035557610124356102b38161078d565b4210610346576102c29061075f565b421015610338576102d16107a4565b845f5260205f206064350361032a577fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc171056020868661031660e4358760c4358a16610926565b610323610104353361098d565b51908152a1005b835163abab6bd760e01b8152fd5b83516337bf561360e11b8152fd5b5083516337bf561360e11b8152fd5b83516348f5c3ed60e01b8152fd5b8390346100be576101403660031901126100be576001600160a01b03833581811692908390036100be57602435916101003660431901126100be5760a43516330361043c576103b06107a4565b61012435901c7f000000000000000000000000000000000000000000000000000000000000000001421061042d577fc4474c2790e13695f6d2b6f1d8e164290b55370f87a542fd7711abe0a1bf40ac93508161041d57610410813361098d565b82519182526020820152a1005b610428813384610926565b610410565b5050516337bf561360e11b8152fd5b505050516348f5c3ed60e01b8152fd5b83346100be575f3660031901126100be57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b83346100be575f3660031901126100be57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b8390346100be576104d936610706565b909390916001600160a01b039190606084013583163303610578578301356105008161078d565b42106103465761050f9061075f565b4210156103385761051f836108ac565b845f5260205f2060208401350361032a577fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc171056020868661032360c08861057060a08201353360808401358c16610926565b01353361098d565b5083516348f5c3ed60e01b8152fd5b8285346100be5761059736610706565b6370a0823160e01b855233858501529460209491936001600160a01b039290919086816024817f000000000000000000000000000000000000000000000000000000000000000088165afa9081156106fc575f916106cf575b50156106c0578087013580911c63ffffffff82881c1681018091116106ad57421061069e5761061e9061075f565b4210156106905761062e866108ac565b835f52845f208587013503610682575060c0856105706103239360a07fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc17105990135908060608501351690608085013516610926565b825163abab6bd760e01b8152fd5b82516337bf561360e11b8152fd5b5082516337bf561360e11b8152fd5b601183634e487b7160e01b5f525260245ffd5b5082516348f5c3ed60e01b8152fd5b90508681813d83116106f5575b6106e68183610729565b810103126100be5751886105f0565b503d6106dc565b85513d5f823e3d90fd5b906101206003198301126100be576101006004359260231901126100be57602490565b90601f8019910116810190811067ffffffffffffffff82111761074b57604052565b634e487b7160e01b5f52604160045260245ffd5b63ffffffff8160e01c9160401c1681018091116107795790565b634e487b7160e01b5f52601160045260245ffd5b63ffffffff8160e01c911681018091116107795790565b600b60405161010090816044823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153605590206001600160a01b0316300361081f57565b604051635134a42560e11b8152600490fd5b600b60405161010090816004823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153605590206001600160a01b0316300361081f57565b600b906040516101008092823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153605590206001600160a01b0316300361081f57565b9160446020925f926040519163a9059cbb60e01b83526004830152602482015282855af1908161096b575b501561095957565b60405163fb7f507960e01b8152600490fd5b90503d15610985575060015f5114601f3d11165b5f610951565b3b151561097f565b5f80809381935af13d156109e6573d67ffffffffffffffff811161074b57604051906109c3601f8201601f191660200183610729565b81525f60203d92013e5b156109d457565b604051638a0332d560e01b8152600490fd5b6109cd56fea26469706673582212200f17a2a85da473d52b744012b0386369f7d81c0e18c66589bb75289742857e6264736f6c63430008170033",
							"opcodes": "PUSH2 0x100 CALLVALUE PUSH2 0x115 JUMPI PUSH1 0x1F PUSH2 0xB4F CODESIZE DUP2 SWAP1 SUB SWAP2 DUP3 ADD PUSH1 0x1F NOT AND DUP4 ADD SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP4 GT DUP5 DUP5 LT OR PUSH2 0x119 JUMPI DUP1 DUP5 SWAP3 PUSH1 0x40 SWAP5 DUP6 MSTORE DUP4 CODECOPY DUP2 ADD SUB SLT PUSH2 0x115 JUMPI DUP1 MLOAD SWAP1 PUSH4 0xFFFFFFFF DUP3 AND DUP1 SWAP3 SUB PUSH2 0x115 JUMPI PUSH1 0x20 ADD MLOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND DUP3 SUB PUSH2 0x115 JUMPI CALLER PUSH1 0xC0 MSTORE PUSH1 0xA0 MSTORE PUSH1 0x80 MSTORE PUSH15 0x5AF43D82803E903D91602B57FD5BF3 PUSH1 0x20 MSTORE ADDRESS PUSH1 0x11 MSTORE PUSH23 0x3D602D80600A3D3981F3363D3D373D3D3D363D73000000 ADDRESS PUSH1 0x88 SHR OR PUSH0 MSTORE PUSH1 0x37 PUSH1 0x9 KECCAK256 PUSH1 0xE0 MSTORE PUSH1 0x40 MLOAD PUSH2 0xA21 SWAP1 DUP2 PUSH2 0x12E DUP3 CODECOPY PUSH1 0x80 MLOAD DUP2 DUP2 DUP2 PUSH1 0xF8 ADD MSTORE PUSH2 0x5BF ADD MSTORE PUSH1 0xA0 MLOAD DUP2 DUP2 DUP2 PUSH1 0x9B ADD MSTORE PUSH2 0x3B8 ADD MSTORE PUSH1 0xC0 MLOAD DUP2 DUP2 DUP2 PUSH2 0x49A ADD MSTORE DUP2 DUP2 PUSH2 0x7E4 ADD MSTORE DUP2 DUP2 PUSH2 0x871 ADD MSTORE PUSH2 0x8EB ADD MSTORE PUSH1 0xE0 MLOAD DUP2 DUP2 DUP2 PUSH2 0x463 ADD MSTORE DUP2 DUP2 PUSH2 0x7B9 ADD MSTORE DUP2 DUP2 PUSH2 0x846 ADD MSTORE PUSH2 0x8C0 ADD MSTORE RETURN JUMPDEST PUSH0 DUP1 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT INVALID PUSH1 0x80 PUSH1 0x40 SWAP1 DUP1 DUP3 MSTORE PUSH1 0x4 DUP1 CALLDATASIZE LT ISZERO PUSH2 0x15 JUMPI PUSH0 DUP1 REVERT JUMPDEST PUSH1 0xE0 PUSH0 CALLDATALOAD DUP2 SHR SWAP3 DUP4 PUSH4 0xAF97558 EQ PUSH2 0x587 JUMPI POP DUP3 PUSH4 0x23305703 EQ PUSH2 0x4C9 JUMPI DUP3 PUSH4 0x2DD31000 EQ PUSH2 0x486 JUMPI DUP3 PUSH4 0x34862B6A EQ PUSH2 0x44C JUMPI DUP3 PUSH4 0x4649088B EQ PUSH2 0x363 JUMPI DUP3 PUSH4 0x6C10C0C8 EQ PUSH2 0x261 JUMPI DUP3 PUSH4 0x90D3252F EQ PUSH2 0x20D JUMPI DUP3 PUSH4 0xDAFF233E EQ PUSH2 0xC2 JUMPI POP POP PUSH4 0xF56CD69C EQ PUSH2 0x85 JUMPI PUSH0 DUP1 REVERT JUMPDEST CALLVALUE PUSH2 0xBE JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x20 SWAP1 MLOAD PUSH32 0x0 DUP2 MSTORE RETURN JUMPDEST PUSH0 DUP1 REVERT JUMPDEST DUP4 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x100 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI DUP1 MLOAD PUSH4 0x70A08231 PUSH1 0xE0 SHL DUP2 MSTORE CALLER DUP5 DUP3 ADD MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 SWAP1 PUSH1 0x20 DUP2 PUSH1 0x24 DUP2 PUSH32 0x0 DUP9 AND GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x203 JUMPI PUSH0 SWAP2 PUSH2 0x1D1 JUMPI JUMPDEST POP ISZERO PUSH2 0x1C1 JUMPI PUSH4 0xFFFFFFFF PUSH1 0xE4 CALLDATALOAD DUP1 SWAP3 SHR SWAP2 PUSH1 0x60 SHR AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x1AE JUMPI TIMESTAMP LT PUSH2 0x19F JUMPI PUSH2 0x16D DUP3 PUSH2 0x15A PUSH2 0x831 JUMP JUMPDEST PUSH1 0xA4 CALLDATALOAD SWAP1 DUP1 PUSH1 0x44 CALLDATALOAD AND SWAP1 PUSH1 0x84 CALLDATALOAD AND PUSH2 0x926 JUMP JUMPDEST PUSH2 0x179 PUSH1 0xC4 CALLDATALOAD CALLER PUSH2 0x98D JUMP JUMPDEST PUSH32 0x6E3BE9294E58D10B9C8053CFD5E09871B67E442FE394D6B0870D336B9DF984A9 PUSH0 DUP1 LOG1 STOP JUMPDEST MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 POP REVERT JUMPDEST PUSH1 0x11 DUP5 PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST DUP2 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE DUP5 SWAP1 REVERT JUMPDEST SWAP1 POP PUSH1 0x20 DUP2 RETURNDATASIZE PUSH1 0x20 GT PUSH2 0x1FB JUMPI JUMPDEST DUP2 PUSH2 0x1EC PUSH1 0x20 SWAP4 DUP4 PUSH2 0x729 JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0xBE JUMPI MLOAD DUP6 PUSH2 0x129 JUMP JUMPDEST RETURNDATASIZE SWAP2 POP PUSH2 0x1DF JUMP JUMPDEST DUP4 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST POP DUP3 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x100 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 PUSH1 0x64 CALLDATALOAD DUP3 AND CALLER SUB PUSH2 0x252 JUMPI PUSH2 0x240 PUSH1 0xE4 CALLDATALOAD PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT PUSH2 0x19F JUMPI PUSH2 0x16D DUP3 PUSH2 0x15A PUSH2 0x831 JUMP JUMPDEST MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE SWAP1 POP REVERT JUMPDEST POP DUP3 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x140 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI DUP2 CALLDATALOAD SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 PUSH1 0x24 CALLDATALOAD SWAP1 DUP3 DUP3 AND DUP3 SUB PUSH2 0xBE JUMPI PUSH2 0x100 CALLDATASIZE PUSH1 0x43 NOT ADD SLT PUSH2 0xBE JUMPI DUP3 PUSH1 0xA4 CALLDATALOAD AND CALLER SUB PUSH2 0x355 JUMPI PUSH2 0x124 CALLDATALOAD PUSH2 0x2B3 DUP2 PUSH2 0x78D JUMP JUMPDEST TIMESTAMP LT PUSH2 0x346 JUMPI PUSH2 0x2C2 SWAP1 PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT ISZERO PUSH2 0x338 JUMPI PUSH2 0x2D1 PUSH2 0x7A4 JUMP JUMPDEST DUP5 PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 PUSH1 0x64 CALLDATALOAD SUB PUSH2 0x32A JUMPI PUSH32 0xE346F5C97A360DB5188BFA5D3EC5F0583ABDE420C6BA4D08B6CFE61ADDC17105 PUSH1 0x20 DUP7 DUP7 PUSH2 0x316 PUSH1 0xE4 CALLDATALOAD DUP8 PUSH1 0xC4 CALLDATALOAD DUP11 AND PUSH2 0x926 JUMP JUMPDEST PUSH2 0x323 PUSH2 0x104 CALLDATALOAD CALLER PUSH2 0x98D JUMP JUMPDEST MLOAD SWAP1 DUP2 MSTORE LOG1 STOP JUMPDEST DUP4 MLOAD PUSH4 0xABAB6BD7 PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST POP DUP4 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 SWAP1 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x140 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 CALLDATALOAD DUP2 DUP2 AND SWAP3 SWAP1 DUP4 SWAP1 SUB PUSH2 0xBE JUMPI PUSH1 0x24 CALLDATALOAD SWAP2 PUSH2 0x100 CALLDATASIZE PUSH1 0x43 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0xA4 CALLDATALOAD AND CALLER SUB PUSH2 0x43C JUMPI PUSH2 0x3B0 PUSH2 0x7A4 JUMP JUMPDEST PUSH2 0x124 CALLDATALOAD SWAP1 SHR PUSH32 0x0 ADD TIMESTAMP LT PUSH2 0x42D JUMPI PUSH32 0xC4474C2790E13695F6D2B6F1D8E164290B55370F87A542FD7711ABE0A1BF40AC SWAP4 POP DUP2 PUSH2 0x41D JUMPI PUSH2 0x410 DUP2 CALLER PUSH2 0x98D JUMP JUMPDEST DUP3 MLOAD SWAP2 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE LOG1 STOP JUMPDEST PUSH2 0x428 DUP2 CALLER DUP5 PUSH2 0x926 JUMP JUMPDEST PUSH2 0x410 JUMP JUMPDEST POP POP MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST POP POP POP MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 CALLVALUE PUSH2 0xBE JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x20 SWAP1 MLOAD PUSH32 0x0 DUP2 MSTORE RETURN JUMPDEST DUP4 CALLVALUE PUSH2 0xBE JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI MLOAD PUSH32 0x0 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 MSTORE PUSH1 0x20 SWAP1 RETURN JUMPDEST DUP4 SWAP1 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x4D9 CALLDATASIZE PUSH2 0x706 JUMP JUMPDEST SWAP1 SWAP4 SWAP1 SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 SWAP1 PUSH1 0x60 DUP5 ADD CALLDATALOAD DUP4 AND CALLER SUB PUSH2 0x578 JUMPI DUP4 ADD CALLDATALOAD PUSH2 0x500 DUP2 PUSH2 0x78D JUMP JUMPDEST TIMESTAMP LT PUSH2 0x346 JUMPI PUSH2 0x50F SWAP1 PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT ISZERO PUSH2 0x338 JUMPI PUSH2 0x51F DUP4 PUSH2 0x8AC JUMP JUMPDEST DUP5 PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 PUSH1 0x20 DUP5 ADD CALLDATALOAD SUB PUSH2 0x32A JUMPI PUSH32 0xE346F5C97A360DB5188BFA5D3EC5F0583ABDE420C6BA4D08B6CFE61ADDC17105 PUSH1 0x20 DUP7 DUP7 PUSH2 0x323 PUSH1 0xC0 DUP9 PUSH2 0x570 PUSH1 0xA0 DUP3 ADD CALLDATALOAD CALLER PUSH1 0x80 DUP5 ADD CALLDATALOAD DUP13 AND PUSH2 0x926 JUMP JUMPDEST ADD CALLDATALOAD CALLER PUSH2 0x98D JUMP JUMPDEST POP DUP4 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP3 DUP6 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x597 CALLDATASIZE PUSH2 0x706 JUMP JUMPDEST PUSH4 0x70A08231 PUSH1 0xE0 SHL DUP6 MSTORE CALLER DUP6 DUP6 ADD MSTORE SWAP5 PUSH1 0x20 SWAP5 SWAP2 SWAP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 SWAP1 SWAP2 SWAP1 DUP7 DUP2 PUSH1 0x24 DUP2 PUSH32 0x0 DUP9 AND GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x6FC JUMPI PUSH0 SWAP2 PUSH2 0x6CF JUMPI JUMPDEST POP ISZERO PUSH2 0x6C0 JUMPI DUP1 DUP8 ADD CALLDATALOAD DUP1 SWAP2 SHR PUSH4 0xFFFFFFFF DUP3 DUP9 SHR AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x6AD JUMPI TIMESTAMP LT PUSH2 0x69E JUMPI PUSH2 0x61E SWAP1 PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT ISZERO PUSH2 0x690 JUMPI PUSH2 0x62E DUP7 PUSH2 0x8AC JUMP JUMPDEST DUP4 PUSH0 MSTORE DUP5 PUSH0 KECCAK256 DUP6 DUP8 ADD CALLDATALOAD SUB PUSH2 0x682 JUMPI POP PUSH1 0xC0 DUP6 PUSH2 0x570 PUSH2 0x323 SWAP4 PUSH1 0xA0 PUSH32 0xE346F5C97A360DB5188BFA5D3EC5F0583ABDE420C6BA4D08B6CFE61ADDC17105 SWAP10 ADD CALLDATALOAD SWAP1 DUP1 PUSH1 0x60 DUP6 ADD CALLDATALOAD AND SWAP1 PUSH1 0x80 DUP6 ADD CALLDATALOAD AND PUSH2 0x926 JUMP JUMPDEST DUP3 MLOAD PUSH4 0xABAB6BD7 PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP3 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST POP DUP3 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST PUSH1 0x11 DUP4 PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST POP DUP3 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST SWAP1 POP DUP7 DUP2 DUP2 RETURNDATASIZE DUP4 GT PUSH2 0x6F5 JUMPI JUMPDEST PUSH2 0x6E6 DUP2 DUP4 PUSH2 0x729 JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0xBE JUMPI MLOAD DUP9 PUSH2 0x5F0 JUMP JUMPDEST POP RETURNDATASIZE PUSH2 0x6DC JUMP JUMPDEST DUP6 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST SWAP1 PUSH2 0x120 PUSH1 0x3 NOT DUP4 ADD SLT PUSH2 0xBE JUMPI PUSH2 0x100 PUSH1 0x4 CALLDATALOAD SWAP3 PUSH1 0x23 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x24 SWAP1 JUMP JUMPDEST SWAP1 PUSH1 0x1F DUP1 NOT SWAP2 ADD AND DUP2 ADD SWAP1 DUP2 LT PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT OR PUSH2 0x74B JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH4 0xFFFFFFFF DUP2 PUSH1 0xE0 SHR SWAP2 PUSH1 0x40 SHR AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x779 JUMPI SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH4 0xFFFFFFFF DUP2 PUSH1 0xE0 SHR SWAP2 AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x779 JUMPI SWAP1 JUMP JUMPDEST PUSH1 0xB PUSH1 0x40 MLOAD PUSH2 0x100 SWAP1 DUP2 PUSH1 0x44 DUP3 CALLDATACOPY KECCAK256 PUSH1 0x40 MLOAD SWAP1 PUSH32 0x0 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x20 DUP3 ADD MSTORE PUSH32 0x0 DUP2 MSTORE ADD PUSH1 0xFF DUP2 MSTORE8 PUSH1 0x55 SWAP1 KECCAK256 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND ADDRESS SUB PUSH2 0x81F JUMPI JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x5134A425 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x4 SWAP1 REVERT JUMPDEST PUSH1 0xB PUSH1 0x40 MLOAD PUSH2 0x100 SWAP1 DUP2 PUSH1 0x4 DUP3 CALLDATACOPY KECCAK256 PUSH1 0x40 MLOAD SWAP1 PUSH32 0x0 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x20 DUP3 ADD MSTORE PUSH32 0x0 DUP2 MSTORE ADD PUSH1 0xFF DUP2 MSTORE8 PUSH1 0x55 SWAP1 KECCAK256 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND ADDRESS SUB PUSH2 0x81F JUMPI JUMP JUMPDEST PUSH1 0xB SWAP1 PUSH1 0x40 MLOAD PUSH2 0x100 DUP1 SWAP3 DUP3 CALLDATACOPY KECCAK256 PUSH1 0x40 MLOAD SWAP1 PUSH32 0x0 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x20 DUP3 ADD MSTORE PUSH32 0x0 DUP2 MSTORE ADD PUSH1 0xFF DUP2 MSTORE8 PUSH1 0x55 SWAP1 KECCAK256 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND ADDRESS SUB PUSH2 0x81F JUMPI JUMP JUMPDEST SWAP2 PUSH1 0x44 PUSH1 0x20 SWAP3 PUSH0 SWAP3 PUSH1 0x40 MLOAD SWAP2 PUSH4 0xA9059CBB PUSH1 0xE0 SHL DUP4 MSTORE PUSH1 0x4 DUP4 ADD MSTORE PUSH1 0x24 DUP3 ADD MSTORE DUP3 DUP6 GAS CALL SWAP1 DUP2 PUSH2 0x96B JUMPI JUMPDEST POP ISZERO PUSH2 0x959 JUMPI JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0xFB7F5079 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 SWAP1 REVERT JUMPDEST SWAP1 POP RETURNDATASIZE ISZERO PUSH2 0x985 JUMPI POP PUSH1 0x1 PUSH0 MLOAD EQ PUSH1 0x1F RETURNDATASIZE GT AND JUMPDEST PUSH0 PUSH2 0x951 JUMP JUMPDEST EXTCODESIZE ISZERO ISZERO PUSH2 0x97F JUMP JUMPDEST PUSH0 DUP1 DUP1 SWAP4 DUP2 SWAP4 GAS CALL RETURNDATASIZE ISZERO PUSH2 0x9E6 JUMPI RETURNDATASIZE PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x74B JUMPI PUSH1 0x40 MLOAD SWAP1 PUSH2 0x9C3 PUSH1 0x1F DUP3 ADD PUSH1 0x1F NOT AND PUSH1 0x20 ADD DUP4 PUSH2 0x729 JUMP JUMPDEST DUP2 MSTORE PUSH0 PUSH1 0x20 RETURNDATASIZE SWAP3 ADD RETURNDATACOPY JUMPDEST ISZERO PUSH2 0x9D4 JUMPI JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x8A0332D5 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 SWAP1 REVERT JUMPDEST PUSH2 0x9CD JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xF OR LOG2 0xA8 0x5D LOG4 PUSH20 0xD52B744012B0386369F7D81C0E18C66589BB7528 SWAP8 TIMESTAMP DUP6 PUSH31 0x6264736F6C6343000817003300000000000000000000000000000000000000 ",
							"sourceMap": "968:4515:13:-:0;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;-1:-1:-1;;;;;968:4515:13;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;968:4515:13;;;;;;1137:10:10;;;1216:26;;1252:27;;561:488:18;968:4515:13;561:488:18;794:4:12;561:488:18;;;794:4:12;561:488:18;;;-1:-1:-1;561:488:18;;;;748:52:12;;968:4515:13;;;;;;;;1252:27:10;968:4515:13;;;;;;;;;;1216:26:10;968:4515:13;;;;;;;;;;1137:10:10;968:4515:13;;;;;;;;;;;;;;;;;;;;748:52:12;968:4515:13;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;968:4515:13;;;;;;-1:-1:-1;968:4515:13;;;;;-1:-1:-1;968:4515:13"
						},
						"deployedBytecode": {
							"functionDebugData": {
								"abi_decode_bytes32t_struct_Immutables_calldata": {
									"entryPoint": 1798,
									"id": null,
									"parameterSlots": 1,
									"returnSlots": 2
								},
								"finalize_allocation": {
									"entryPoint": 1833,
									"id": null,
									"parameterSlots": 2,
									"returnSlots": 0
								},
								"fun_ethTransfer": {
									"entryPoint": 2445,
									"id": 1176,
									"parameterSlots": 2,
									"returnSlots": 0
								},
								"fun_get": {
									"entryPoint": 1887,
									"id": 1954,
									"parameterSlots": 1,
									"returnSlots": 1
								},
								"fun_get_10449": {
									"entryPoint": 1933,
									"id": 1954,
									"parameterSlots": 1,
									"returnSlots": 1
								},
								"fun_safeTransfer": {
									"entryPoint": 2342,
									"id": 591,
									"parameterSlots": 3,
									"returnSlots": 0
								},
								"fun_validateImmutables": {
									"entryPoint": 2220,
									"id": 1355,
									"parameterSlots": 1,
									"returnSlots": 0
								},
								"fun_validateImmutables_10452": {
									"entryPoint": 1956,
									"id": 1355,
									"parameterSlots": 0,
									"returnSlots": 0
								},
								"fun_validateImmutables_10458": {
									"entryPoint": 2097,
									"id": 1355,
									"parameterSlots": 0,
									"returnSlots": 0
								}
							},
							"generatedSources": [],
							"immutableReferences": {
								"966": [
									{
										"length": 32,
										"start": 248
									},
									{
										"length": 32,
										"start": 1471
									}
								],
								"969": [
									{
										"length": 32,
										"start": 155
									},
									{
										"length": 32,
										"start": 952
									}
								],
								"974": [
									{
										"length": 32,
										"start": 1178
									},
									{
										"length": 32,
										"start": 2020
									},
									{
										"length": 32,
										"start": 2161
									},
									{
										"length": 32,
										"start": 2283
									}
								],
								"1324": [
									{
										"length": 32,
										"start": 1123
									},
									{
										"length": 32,
										"start": 1977
									},
									{
										"length": 32,
										"start": 2118
									},
									{
										"length": 32,
										"start": 2240
									}
								]
							},
							"linkReferences": {},
							"object": "6080604090808252600480361015610015575f80fd5b60e05f35811c9283630af97558146105875750826323305703146104c95782632dd310001461048657826334862b6a1461044c5782634649088b146103635782636c10c0c81461026157826390d3252f1461020d578263daff233e146100c257505063f56cd69c14610085575f80fd5b346100be575f3660031901126100be57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5f80fd5b83346100be576101003660031901126100be5780516370a0823160e01b815233848201526001600160a01b0392906020816024817f000000000000000000000000000000000000000000000000000000000000000088165afa908115610203575f916101d1575b50156101c15763ffffffff60e43580921c9160601c1681018091116101ae57421061019f5761016d8261015a610831565b60a4359080604435169060843516610926565b61017960c4353361098d565b7f6e3be9294e58d10b9c8053cfd5e09871b67e442fe394d6b0870d336b9df984a95f80a1005b516337bf561360e11b81529050fd5b601184634e487b7160e01b5f525260245ffd5b81516348f5c3ed60e01b81528490fd5b90506020813d6020116101fb575b816101ec60209383610729565b810103126100be575185610129565b3d91506101df565b83513d5f823e3d90fd5b5082346100be576101003660031901126100be576001600160a01b0390606435821633036102525761024060e43561075f565b421061019f5761016d8261015a610831565b516348f5c3ed60e01b81529050fd5b5082346100be576101403660031901126100be578135916001600160a01b03906024359082821682036100be576101003660431901126100be578260a43516330361035557610124356102b38161078d565b4210610346576102c29061075f565b421015610338576102d16107a4565b845f5260205f206064350361032a577fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc171056020868661031660e4358760c4358a16610926565b610323610104353361098d565b51908152a1005b835163abab6bd760e01b8152fd5b83516337bf561360e11b8152fd5b5083516337bf561360e11b8152fd5b83516348f5c3ed60e01b8152fd5b8390346100be576101403660031901126100be576001600160a01b03833581811692908390036100be57602435916101003660431901126100be5760a43516330361043c576103b06107a4565b61012435901c7f000000000000000000000000000000000000000000000000000000000000000001421061042d577fc4474c2790e13695f6d2b6f1d8e164290b55370f87a542fd7711abe0a1bf40ac93508161041d57610410813361098d565b82519182526020820152a1005b610428813384610926565b610410565b5050516337bf561360e11b8152fd5b505050516348f5c3ed60e01b8152fd5b83346100be575f3660031901126100be57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b83346100be575f3660031901126100be57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b8390346100be576104d936610706565b909390916001600160a01b039190606084013583163303610578578301356105008161078d565b42106103465761050f9061075f565b4210156103385761051f836108ac565b845f5260205f2060208401350361032a577fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc171056020868661032360c08861057060a08201353360808401358c16610926565b01353361098d565b5083516348f5c3ed60e01b8152fd5b8285346100be5761059736610706565b6370a0823160e01b855233858501529460209491936001600160a01b039290919086816024817f000000000000000000000000000000000000000000000000000000000000000088165afa9081156106fc575f916106cf575b50156106c0578087013580911c63ffffffff82881c1681018091116106ad57421061069e5761061e9061075f565b4210156106905761062e866108ac565b835f52845f208587013503610682575060c0856105706103239360a07fe346f5c97a360db5188bfa5d3ec5f0583abde420c6ba4d08b6cfe61addc17105990135908060608501351690608085013516610926565b825163abab6bd760e01b8152fd5b82516337bf561360e11b8152fd5b5082516337bf561360e11b8152fd5b601183634e487b7160e01b5f525260245ffd5b5082516348f5c3ed60e01b8152fd5b90508681813d83116106f5575b6106e68183610729565b810103126100be5751886105f0565b503d6106dc565b85513d5f823e3d90fd5b906101206003198301126100be576101006004359260231901126100be57602490565b90601f8019910116810190811067ffffffffffffffff82111761074b57604052565b634e487b7160e01b5f52604160045260245ffd5b63ffffffff8160e01c9160401c1681018091116107795790565b634e487b7160e01b5f52601160045260245ffd5b63ffffffff8160e01c911681018091116107795790565b600b60405161010090816044823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153605590206001600160a01b0316300361081f57565b604051635134a42560e11b8152600490fd5b600b60405161010090816004823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153605590206001600160a01b0316300361081f57565b600b906040516101008092823720604051907f0000000000000000000000000000000000000000000000000000000000000000604083015260208201527f000000000000000000000000000000000000000000000000000000000000000081520160ff8153605590206001600160a01b0316300361081f57565b9160446020925f926040519163a9059cbb60e01b83526004830152602482015282855af1908161096b575b501561095957565b60405163fb7f507960e01b8152600490fd5b90503d15610985575060015f5114601f3d11165b5f610951565b3b151561097f565b5f80809381935af13d156109e6573d67ffffffffffffffff811161074b57604051906109c3601f8201601f191660200183610729565b81525f60203d92013e5b156109d457565b604051638a0332d560e01b8152600490fd5b6109cd56fea26469706673582212200f17a2a85da473d52b744012b0386369f7d81c0e18c66589bb75289742857e6264736f6c63430008170033",
							"opcodes": "PUSH1 0x80 PUSH1 0x40 SWAP1 DUP1 DUP3 MSTORE PUSH1 0x4 DUP1 CALLDATASIZE LT ISZERO PUSH2 0x15 JUMPI PUSH0 DUP1 REVERT JUMPDEST PUSH1 0xE0 PUSH0 CALLDATALOAD DUP2 SHR SWAP3 DUP4 PUSH4 0xAF97558 EQ PUSH2 0x587 JUMPI POP DUP3 PUSH4 0x23305703 EQ PUSH2 0x4C9 JUMPI DUP3 PUSH4 0x2DD31000 EQ PUSH2 0x486 JUMPI DUP3 PUSH4 0x34862B6A EQ PUSH2 0x44C JUMPI DUP3 PUSH4 0x4649088B EQ PUSH2 0x363 JUMPI DUP3 PUSH4 0x6C10C0C8 EQ PUSH2 0x261 JUMPI DUP3 PUSH4 0x90D3252F EQ PUSH2 0x20D JUMPI DUP3 PUSH4 0xDAFF233E EQ PUSH2 0xC2 JUMPI POP POP PUSH4 0xF56CD69C EQ PUSH2 0x85 JUMPI PUSH0 DUP1 REVERT JUMPDEST CALLVALUE PUSH2 0xBE JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x20 SWAP1 MLOAD PUSH32 0x0 DUP2 MSTORE RETURN JUMPDEST PUSH0 DUP1 REVERT JUMPDEST DUP4 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x100 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI DUP1 MLOAD PUSH4 0x70A08231 PUSH1 0xE0 SHL DUP2 MSTORE CALLER DUP5 DUP3 ADD MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 SWAP1 PUSH1 0x20 DUP2 PUSH1 0x24 DUP2 PUSH32 0x0 DUP9 AND GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x203 JUMPI PUSH0 SWAP2 PUSH2 0x1D1 JUMPI JUMPDEST POP ISZERO PUSH2 0x1C1 JUMPI PUSH4 0xFFFFFFFF PUSH1 0xE4 CALLDATALOAD DUP1 SWAP3 SHR SWAP2 PUSH1 0x60 SHR AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x1AE JUMPI TIMESTAMP LT PUSH2 0x19F JUMPI PUSH2 0x16D DUP3 PUSH2 0x15A PUSH2 0x831 JUMP JUMPDEST PUSH1 0xA4 CALLDATALOAD SWAP1 DUP1 PUSH1 0x44 CALLDATALOAD AND SWAP1 PUSH1 0x84 CALLDATALOAD AND PUSH2 0x926 JUMP JUMPDEST PUSH2 0x179 PUSH1 0xC4 CALLDATALOAD CALLER PUSH2 0x98D JUMP JUMPDEST PUSH32 0x6E3BE9294E58D10B9C8053CFD5E09871B67E442FE394D6B0870D336B9DF984A9 PUSH0 DUP1 LOG1 STOP JUMPDEST MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 POP REVERT JUMPDEST PUSH1 0x11 DUP5 PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST DUP2 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE DUP5 SWAP1 REVERT JUMPDEST SWAP1 POP PUSH1 0x20 DUP2 RETURNDATASIZE PUSH1 0x20 GT PUSH2 0x1FB JUMPI JUMPDEST DUP2 PUSH2 0x1EC PUSH1 0x20 SWAP4 DUP4 PUSH2 0x729 JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0xBE JUMPI MLOAD DUP6 PUSH2 0x129 JUMP JUMPDEST RETURNDATASIZE SWAP2 POP PUSH2 0x1DF JUMP JUMPDEST DUP4 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST POP DUP3 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x100 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 PUSH1 0x64 CALLDATALOAD DUP3 AND CALLER SUB PUSH2 0x252 JUMPI PUSH2 0x240 PUSH1 0xE4 CALLDATALOAD PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT PUSH2 0x19F JUMPI PUSH2 0x16D DUP3 PUSH2 0x15A PUSH2 0x831 JUMP JUMPDEST MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE SWAP1 POP REVERT JUMPDEST POP DUP3 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x140 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI DUP2 CALLDATALOAD SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 PUSH1 0x24 CALLDATALOAD SWAP1 DUP3 DUP3 AND DUP3 SUB PUSH2 0xBE JUMPI PUSH2 0x100 CALLDATASIZE PUSH1 0x43 NOT ADD SLT PUSH2 0xBE JUMPI DUP3 PUSH1 0xA4 CALLDATALOAD AND CALLER SUB PUSH2 0x355 JUMPI PUSH2 0x124 CALLDATALOAD PUSH2 0x2B3 DUP2 PUSH2 0x78D JUMP JUMPDEST TIMESTAMP LT PUSH2 0x346 JUMPI PUSH2 0x2C2 SWAP1 PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT ISZERO PUSH2 0x338 JUMPI PUSH2 0x2D1 PUSH2 0x7A4 JUMP JUMPDEST DUP5 PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 PUSH1 0x64 CALLDATALOAD SUB PUSH2 0x32A JUMPI PUSH32 0xE346F5C97A360DB5188BFA5D3EC5F0583ABDE420C6BA4D08B6CFE61ADDC17105 PUSH1 0x20 DUP7 DUP7 PUSH2 0x316 PUSH1 0xE4 CALLDATALOAD DUP8 PUSH1 0xC4 CALLDATALOAD DUP11 AND PUSH2 0x926 JUMP JUMPDEST PUSH2 0x323 PUSH2 0x104 CALLDATALOAD CALLER PUSH2 0x98D JUMP JUMPDEST MLOAD SWAP1 DUP2 MSTORE LOG1 STOP JUMPDEST DUP4 MLOAD PUSH4 0xABAB6BD7 PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST POP DUP4 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 SWAP1 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x140 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 CALLDATALOAD DUP2 DUP2 AND SWAP3 SWAP1 DUP4 SWAP1 SUB PUSH2 0xBE JUMPI PUSH1 0x24 CALLDATALOAD SWAP2 PUSH2 0x100 CALLDATASIZE PUSH1 0x43 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0xA4 CALLDATALOAD AND CALLER SUB PUSH2 0x43C JUMPI PUSH2 0x3B0 PUSH2 0x7A4 JUMP JUMPDEST PUSH2 0x124 CALLDATALOAD SWAP1 SHR PUSH32 0x0 ADD TIMESTAMP LT PUSH2 0x42D JUMPI PUSH32 0xC4474C2790E13695F6D2B6F1D8E164290B55370F87A542FD7711ABE0A1BF40AC SWAP4 POP DUP2 PUSH2 0x41D JUMPI PUSH2 0x410 DUP2 CALLER PUSH2 0x98D JUMP JUMPDEST DUP3 MLOAD SWAP2 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE LOG1 STOP JUMPDEST PUSH2 0x428 DUP2 CALLER DUP5 PUSH2 0x926 JUMP JUMPDEST PUSH2 0x410 JUMP JUMPDEST POP POP MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST POP POP POP MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP4 CALLVALUE PUSH2 0xBE JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x20 SWAP1 MLOAD PUSH32 0x0 DUP2 MSTORE RETURN JUMPDEST DUP4 CALLVALUE PUSH2 0xBE JUMPI PUSH0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0xBE JUMPI MLOAD PUSH32 0x0 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 MSTORE PUSH1 0x20 SWAP1 RETURN JUMPDEST DUP4 SWAP1 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x4D9 CALLDATASIZE PUSH2 0x706 JUMP JUMPDEST SWAP1 SWAP4 SWAP1 SWAP2 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP2 SWAP1 PUSH1 0x60 DUP5 ADD CALLDATALOAD DUP4 AND CALLER SUB PUSH2 0x578 JUMPI DUP4 ADD CALLDATALOAD PUSH2 0x500 DUP2 PUSH2 0x78D JUMP JUMPDEST TIMESTAMP LT PUSH2 0x346 JUMPI PUSH2 0x50F SWAP1 PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT ISZERO PUSH2 0x338 JUMPI PUSH2 0x51F DUP4 PUSH2 0x8AC JUMP JUMPDEST DUP5 PUSH0 MSTORE PUSH1 0x20 PUSH0 KECCAK256 PUSH1 0x20 DUP5 ADD CALLDATALOAD SUB PUSH2 0x32A JUMPI PUSH32 0xE346F5C97A360DB5188BFA5D3EC5F0583ABDE420C6BA4D08B6CFE61ADDC17105 PUSH1 0x20 DUP7 DUP7 PUSH2 0x323 PUSH1 0xC0 DUP9 PUSH2 0x570 PUSH1 0xA0 DUP3 ADD CALLDATALOAD CALLER PUSH1 0x80 DUP5 ADD CALLDATALOAD DUP13 AND PUSH2 0x926 JUMP JUMPDEST ADD CALLDATALOAD CALLER PUSH2 0x98D JUMP JUMPDEST POP DUP4 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP3 DUP6 CALLVALUE PUSH2 0xBE JUMPI PUSH2 0x597 CALLDATASIZE PUSH2 0x706 JUMP JUMPDEST PUSH4 0x70A08231 PUSH1 0xE0 SHL DUP6 MSTORE CALLER DUP6 DUP6 ADD MSTORE SWAP5 PUSH1 0x20 SWAP5 SWAP2 SWAP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 SWAP1 SWAP2 SWAP1 DUP7 DUP2 PUSH1 0x24 DUP2 PUSH32 0x0 DUP9 AND GAS STATICCALL SWAP1 DUP2 ISZERO PUSH2 0x6FC JUMPI PUSH0 SWAP2 PUSH2 0x6CF JUMPI JUMPDEST POP ISZERO PUSH2 0x6C0 JUMPI DUP1 DUP8 ADD CALLDATALOAD DUP1 SWAP2 SHR PUSH4 0xFFFFFFFF DUP3 DUP9 SHR AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x6AD JUMPI TIMESTAMP LT PUSH2 0x69E JUMPI PUSH2 0x61E SWAP1 PUSH2 0x75F JUMP JUMPDEST TIMESTAMP LT ISZERO PUSH2 0x690 JUMPI PUSH2 0x62E DUP7 PUSH2 0x8AC JUMP JUMPDEST DUP4 PUSH0 MSTORE DUP5 PUSH0 KECCAK256 DUP6 DUP8 ADD CALLDATALOAD SUB PUSH2 0x682 JUMPI POP PUSH1 0xC0 DUP6 PUSH2 0x570 PUSH2 0x323 SWAP4 PUSH1 0xA0 PUSH32 0xE346F5C97A360DB5188BFA5D3EC5F0583ABDE420C6BA4D08B6CFE61ADDC17105 SWAP10 ADD CALLDATALOAD SWAP1 DUP1 PUSH1 0x60 DUP6 ADD CALLDATALOAD AND SWAP1 PUSH1 0x80 DUP6 ADD CALLDATALOAD AND PUSH2 0x926 JUMP JUMPDEST DUP3 MLOAD PUSH4 0xABAB6BD7 PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST DUP3 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST POP DUP3 MLOAD PUSH4 0x37BF5613 PUSH1 0xE1 SHL DUP2 MSTORE REVERT JUMPDEST PUSH1 0x11 DUP4 PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST POP DUP3 MLOAD PUSH4 0x48F5C3ED PUSH1 0xE0 SHL DUP2 MSTORE REVERT JUMPDEST SWAP1 POP DUP7 DUP2 DUP2 RETURNDATASIZE DUP4 GT PUSH2 0x6F5 JUMPI JUMPDEST PUSH2 0x6E6 DUP2 DUP4 PUSH2 0x729 JUMP JUMPDEST DUP2 ADD SUB SLT PUSH2 0xBE JUMPI MLOAD DUP9 PUSH2 0x5F0 JUMP JUMPDEST POP RETURNDATASIZE PUSH2 0x6DC JUMP JUMPDEST DUP6 MLOAD RETURNDATASIZE PUSH0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST SWAP1 PUSH2 0x120 PUSH1 0x3 NOT DUP4 ADD SLT PUSH2 0xBE JUMPI PUSH2 0x100 PUSH1 0x4 CALLDATALOAD SWAP3 PUSH1 0x23 NOT ADD SLT PUSH2 0xBE JUMPI PUSH1 0x24 SWAP1 JUMP JUMPDEST SWAP1 PUSH1 0x1F DUP1 NOT SWAP2 ADD AND DUP2 ADD SWAP1 DUP2 LT PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT OR PUSH2 0x74B JUMPI PUSH1 0x40 MSTORE JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH4 0xFFFFFFFF DUP2 PUSH1 0xE0 SHR SWAP2 PUSH1 0x40 SHR AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x779 JUMPI SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH0 REVERT JUMPDEST PUSH4 0xFFFFFFFF DUP2 PUSH1 0xE0 SHR SWAP2 AND DUP2 ADD DUP1 SWAP2 GT PUSH2 0x779 JUMPI SWAP1 JUMP JUMPDEST PUSH1 0xB PUSH1 0x40 MLOAD PUSH2 0x100 SWAP1 DUP2 PUSH1 0x44 DUP3 CALLDATACOPY KECCAK256 PUSH1 0x40 MLOAD SWAP1 PUSH32 0x0 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x20 DUP3 ADD MSTORE PUSH32 0x0 DUP2 MSTORE ADD PUSH1 0xFF DUP2 MSTORE8 PUSH1 0x55 SWAP1 KECCAK256 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND ADDRESS SUB PUSH2 0x81F JUMPI JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x5134A425 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x4 SWAP1 REVERT JUMPDEST PUSH1 0xB PUSH1 0x40 MLOAD PUSH2 0x100 SWAP1 DUP2 PUSH1 0x4 DUP3 CALLDATACOPY KECCAK256 PUSH1 0x40 MLOAD SWAP1 PUSH32 0x0 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x20 DUP3 ADD MSTORE PUSH32 0x0 DUP2 MSTORE ADD PUSH1 0xFF DUP2 MSTORE8 PUSH1 0x55 SWAP1 KECCAK256 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND ADDRESS SUB PUSH2 0x81F JUMPI JUMP JUMPDEST PUSH1 0xB SWAP1 PUSH1 0x40 MLOAD PUSH2 0x100 DUP1 SWAP3 DUP3 CALLDATACOPY KECCAK256 PUSH1 0x40 MLOAD SWAP1 PUSH32 0x0 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x20 DUP3 ADD MSTORE PUSH32 0x0 DUP2 MSTORE ADD PUSH1 0xFF DUP2 MSTORE8 PUSH1 0x55 SWAP1 KECCAK256 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND ADDRESS SUB PUSH2 0x81F JUMPI JUMP JUMPDEST SWAP2 PUSH1 0x44 PUSH1 0x20 SWAP3 PUSH0 SWAP3 PUSH1 0x40 MLOAD SWAP2 PUSH4 0xA9059CBB PUSH1 0xE0 SHL DUP4 MSTORE PUSH1 0x4 DUP4 ADD MSTORE PUSH1 0x24 DUP3 ADD MSTORE DUP3 DUP6 GAS CALL SWAP1 DUP2 PUSH2 0x96B JUMPI JUMPDEST POP ISZERO PUSH2 0x959 JUMPI JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0xFB7F5079 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 SWAP1 REVERT JUMPDEST SWAP1 POP RETURNDATASIZE ISZERO PUSH2 0x985 JUMPI POP PUSH1 0x1 PUSH0 MLOAD EQ PUSH1 0x1F RETURNDATASIZE GT AND JUMPDEST PUSH0 PUSH2 0x951 JUMP JUMPDEST EXTCODESIZE ISZERO ISZERO PUSH2 0x97F JUMP JUMPDEST PUSH0 DUP1 DUP1 SWAP4 DUP2 SWAP4 GAS CALL RETURNDATASIZE ISZERO PUSH2 0x9E6 JUMPI RETURNDATASIZE PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x74B JUMPI PUSH1 0x40 MLOAD SWAP1 PUSH2 0x9C3 PUSH1 0x1F DUP3 ADD PUSH1 0x1F NOT AND PUSH1 0x20 ADD DUP4 PUSH2 0x729 JUMP JUMPDEST DUP2 MSTORE PUSH0 PUSH1 0x20 RETURNDATASIZE SWAP3 ADD RETURNDATACOPY JUMPDEST ISZERO PUSH2 0x9D4 JUMPI JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x8A0332D5 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 SWAP1 REVERT JUMPDEST PUSH2 0x9CD JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xF OR LOG2 0xA8 0x5D LOG4 PUSH20 0xD52B744012B0386369F7D81C0E18C66589BB7528 SWAP8 TIMESTAMP DUP6 PUSH31 0x6264736F6C6343000817003300000000000000000000000000000000000000 ",
							"sourceMap": "968:4515:13:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;;;;1016:37:10;968:4515:13;;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;;;-1:-1:-1;;;2036:35:10;;2060:10;2036:35;;;968:4515:13;-1:-1:-1;;;;;968:4515:13;;2036:35:10;968:4515:13;;;2036:13:10;968:4515:13;;2036:35:10;;;;;;;968:4515:13;2036:35:10;;;968:4515:13;2036:40:10;;2032:68;;1599:3:19;4224:20:13;968:4515;1599:3:19;;;;968:4515:13;1599:3:19;;;;;;;;;1803:15:10;:23;1799:49;;5364:17:13;1540:10:10;;;:::i;:::-;5364:17:13;968:4515;;;5340:16;968:4515;618:37:0;968:4515:13;5303:16;968:4515;618:37:0;5364:17:13;:::i;:::-;5417:24;;968:4515;2060:10:10;5417:24:13;:::i;:::-;5457:17;968:4515;5457:17;;968:4515;1799:49:10;968:4515:13;-1:-1:-1;;;1835:13:10;;968:4515:13;-1:-1:-1;1835:13:10;1599:3:19;968:4515:13;;;;;;;;;;;2032:68:10;968:4515:13;;-1:-1:-1;;;2085:15:10;;968:4515:13;;2085:15:10;2036:35;;;;;;;;;;;;;;;;;:::i;:::-;;;968:4515:13;;;;;2036:35:10;;;;;;-1:-1:-1;2036:35:10;;;968:4515:13;;;;;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;-1:-1:-1;;;;;968:4515:13;1371:16:10;968:4515:13;618:37:0;;1357:10:10;:36;1353:64;;3681:60:13;:20;968:4515;3681:60;:::i;:::-;1803:15:10;:23;1799:49;;5364:17:13;1540:10:10;;;:::i;1353:64::-;968:4515:13;-1:-1:-1;;;1402:15:10;;968:4515:13;-1:-1:-1;1402:15:10;968:4515:13;;;;;;;;-1:-1:-1;;968:4515:13;;;;;;;-1:-1:-1;;;;;968:4515:13;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;;1371:16:10;968:4515:13;618:37:0;1357:10:10;:36;1353:64;;2369:20:13;968:4515;2369:58;;;:::i;:::-;1803:15:10;:23;1799:49;;2448:60:13;;;:::i;:::-;1803:15:10;1920:23;;1916:49;;1540:10;;:::i;:::-;3559:104;968:4515:13;3559:104:10;968:4515:13;;3559:104:10;1688:19;968:4515:13;1662:45:10;1658:73;;4981:24:13;968:4515;;;4888:17;;968:4515;;4843:16;968:4515;618:37:0;;4888:17:13;:::i;:::-;4941:24;;968:4515;1357:10:10;4941:24:13;:::i;:::-;968:4515;;;;4981:24;968:4515;1658:73:10;968:4515:13;;-1:-1:-1;;;1716:15:10;;;1916:49;968:4515:13;;-1:-1:-1;;;1952:13:10;;;1799:49;-1:-1:-1;968:4515:13;;-1:-1:-1;;;1835:13:10;;;1353:64;968:4515:13;;-1:-1:-1;;;1402:15:10;;;968:4515:13;;;;;;;;-1:-1:-1;;968:4515:13;;;;-1:-1:-1;;;;;968:4515:13;;;;;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;1371:16:10;968:4515:13;618:37:0;1357:10:10;:36;1353:64;;1540:10;;:::i;:::-;2375:20;968:4515:13;1599:3:19;;2408:12:10;968:4515:13;1803:15:10;:23;1799:49;;2491:27;;-1:-1:-1;2698:19:10;968:4515:13;;2750:6:10;1357:10;;2750:6;:::i;:::-;968:4515:13;;;;;;;;;2491:27:10;968:4515:13;2694:143:10;2819:6;1357:10;;2819:6;;:::i;:::-;2694:143;;1799:49;-1:-1:-1;;968:4515:13;-1:-1:-1;;;1835:13:10;;;1353:64;968:4515:13;;;;2085:15:10;;;1402;;;968:4515:13;;;;;;;-1:-1:-1;;968:4515:13;;;;;;;701:99:12;968:4515:13;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;;1102:45:10;-1:-1:-1;;;;;968:4515:13;;;;;;;;;;;;;;;:::i;:::-;;;;;-1:-1:-1;;;;;968:4515:13;;1371:16:10;;;968:4515:13;618:37:0;;1357:10:10;:36;1353:64;;1698:20:13;;968:4515;1698:58;;;:::i;:::-;1803:15:10;:23;1799:49;;1777:60:13;;;:::i;:::-;1803:15:10;1920:23;;1916:49;;1540:10;;;:::i;:::-;3559:104;968:4515:13;3559:104:10;;968:4515:13;3559:104:10;;1688:19;;968:4515:13;1662:45:10;1658:73;;4981:24:13;3559:104:10;4888:17:13;;4941:24;;4888:17;;;;;968:4515;1357:10:10;4843:16:13;;;968:4515;618:37:0;;4888:17:13;:::i;:::-;4941:24;968:4515;1357:10:10;4941:24:13;:::i;1353:64:10:-;-1:-1:-1;968:4515:13;;-1:-1:-1;;;1402:15:10;;;968:4515:13;;;;;;;;;:::i;:::-;-1:-1:-1;;;2036:35:10;;2060:10;2036:35;;;968:4515:13;;2036:35:10;;968:4515:13;;-1:-1:-1;;;;;968:4515:13;;;;2036:35:10;;968:4515:13;2036:35:10;:13;968:4515:13;;2036:35:10;;;;;;;968:4515:13;2036:35:10;;;968:4515:13;2036:40:10;;2032:68;;3030:20:13;;;968:4515;1599:3:19;;;;;;;;;;;;;;;1803:15:10;:23;1799:49;;3115:60:13;;;:::i;:::-;1803:15:10;1920:23;;1916:49;;1540:10;;;:::i;:::-;3559:104;968:4515:13;3559:104:10;;968:4515:13;3559:104:10;1688:19;;;968:4515:13;1662:45:10;1658:73;;4888:17:13;4941:24;4888:17;;4941:24;4888:17;;4981:24;4888:17;;968:4515;3211:16;;;;;968:4515;618:37:0;4843:16:13;;;;968:4515;618:37:0;4888:17:13;:::i;1658:73:10:-;968:4515:13;;-1:-1:-1;;;1716:15:10;;;1916:49;968:4515:13;;-1:-1:-1;;;1952:13:10;;;1799:49;-1:-1:-1;968:4515:13;;-1:-1:-1;;;1835:13:10;;;1599:3:19;968:4515:13;;;;;;;;;;;2032:68:10;-1:-1:-1;968:4515:13;;-1:-1:-1;;;2085:15:10;;;2036:35;;;;;;;;;;;;;;;;:::i;:::-;;;968:4515:13;;;;;2036:35:10;;;;;;;;;968:4515:13;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;2760:320:19;1599:3;;;;;968:4515:13;1599:3:19;;;;;;;;;2760:320;:::o;1599:3::-;968:4515:13;;;-1:-1:-1;968:4515:13;;;;;-1:-1:-1;968:4515:13;2760:320:19;1599:3;;;;;;;;;;;;;2760:320;:::o;916:282:12:-;2564:1647:11;564:195:17;;;;;968:4515:13;564:195:17;;;;2564:1647:11;1093:19:12;;564:195:17;2564:1647:11;;;;;;;1114:7:12;2564:1647:11;;;;;;;;;-1:-1:-1;;;;;2564:1647:11;1134:4:12;1064:75;1060:132;;916:282::o;1060:132::-;564:195:17;968:4515:13;-1:-1:-1;;;1162:19:12;;;;;916:282;2564:1647:11;564:195:17;;;;;968:4515:13;564:195:17;;;;2564:1647:11;1093:19:12;;564:195:17;2564:1647:11;;;;;;;1114:7:12;2564:1647:11;;;;;;;;;-1:-1:-1;;;;;2564:1647:11;1134:4:12;1064:75;1060:132;;916:282::o;:::-;2564:1647:11;916:282:12;564:195:17;;;;;;;;;2564:1647:11;1093:19:12;;564:195:17;2564:1647:11;;;;;;;1114:7:12;2564:1647:11;;;;;;;;;-1:-1:-1;;;;;2564:1647:11;1134:4:12;1064:75;1060:132;;916:282::o;7672:231:9:-;;23199:604;;7672:231;-1:-1:-1;7672:231:9;23199:604;;968:4515:13;;;;23199:604:9;;;;;;;;;;;;;;;;;;7672:231;7789:54;;7785:112;;7672:231::o;7785:112::-;23199:604;968:4515:13;-1:-1:-1;;;7866:20:9;;23199:604;;7866:20;23199:604;;-1:-1:-1;23199:604:9;;;;;;-1:-1:-1;23199:604:9;;;;;;;;;;;;;;;;2919:180:10;3006:28;2919:180;;;;;3006:28;;968:4515:13;;;;;;;;;;;;;;;;;-1:-1:-1;;968:4515:13;;;;;:::i;:::-;;;3006:28:10;968:4515:13;;;;;;3048:8:10;3044:48;;2919:180::o;3044:48::-;968:4515:13;;-1:-1:-1;;;3065:27:10;;;;;968:4515:13;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"rescueDelay\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20\",\"name\":\"accessToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImmutables\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecret\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenSendingFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"EscrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROXY_BYTECODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"publicCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"publicWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"details\":\"Funds are locked in at the time of contract deployment. For this Limit Order Protocol calls the `EscrowFactory.postInteraction` function. To perform any action, the caller must provide the same Immutables values used to deploy the clone contract.\",\"events\":{\"EscrowWithdrawal(bytes32)\":{\"params\":{\"secret\":\"The secret that unlocks the escrow.\"}},\"FundsRescued(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens rescued.\",\"token\":\"The address of the token rescued. Zero address for native token.\"}}},\"kind\":\"dev\",\"methods\":{\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The function works on the time intervals highlighted with capital letters: ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/-- --/-- PRIVATE CANCELLATION --/-- PUBLIC CANCELLATION ----\"},\"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The function works on the time intervals highlighted with capital letters: ---- contract deployed --/-- finality --/-- private withdrawal --/-- public withdrawal --/-- --/-- private cancellation --/-- PUBLIC CANCELLATION ----\"},\"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The function works on the time interval highlighted with capital letters: ---- contract deployed --/-- finality --/-- private withdrawal --/-- PUBLIC WITHDRAWAL --/-- --/-- private cancellation --/-- public cancellation ----\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The function works on the time interval highlighted with capital letters: ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/-- --/-- private cancellation --/-- public cancellation ----\"},\"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The function works on the time interval highlighted with capital letters: ---- contract deployed --/-- finality --/-- PRIVATE WITHDRAWAL --/-- PUBLIC WITHDRAWAL --/-- --/-- private cancellation --/-- public cancellation ----\"}},\"title\":\"Source Escrow contract for cross-chain atomic swap.\",\"version\":1},\"userdoc\":{\"events\":{\"EscrowCancelled()\":{\"notice\":\"Emitted on escrow cancellation.\"},\"EscrowWithdrawal(bytes32)\":{\"notice\":\"Emitted on successful withdrawal.\"},\"FundsRescued(address,uint256)\":{\"notice\":\"Emitted when funds are rescued.\"}},\"kind\":\"user\",\"methods\":{\"FACTORY()\":{\"notice\":\"See {IBaseEscrow-FACTORY}.\"},\"PROXY_BYTECODE_HASH()\":{\"notice\":\"See {IEscrow-PROXY_BYTECODE_HASH}.\"},\"RESCUE_DELAY()\":{\"notice\":\"See {IBaseEscrow-RESCUE_DELAY}.\"},\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IBaseEscrow-cancel}.\"},\"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IEscrowSrc-publicCancel}.\"},\"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IEscrowSrc-publicWithdraw}.\"},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IBaseEscrow-rescueFunds}.\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IBaseEscrow-withdraw}.\"},\"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"See {IEscrowSrc-withdrawTo}.\"}},\"notice\":\"Contract to initially lock funds and then unlock them with verification of the secret presented.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/EscrowSrc.sol\":\"EscrowSrc\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/Errors.sol\":{\"keccak256\":\"0x1b0625096e82d06abdcf1844172ef78ef54a5e878761f4d905fda07eaf098424\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5cd99f1a4836c07461cb3ea023ae2f6d1d01e80694b764a87623aa7252754756\",\"dweb:/ipfs/QmNPNDuiNU6TJatZcdBcrwixBoo5MSXNDq4kaXhpJLWGpB\"]},\"contracts/IDaiLikePermit.sol\":{\"keccak256\":\"0x0bcc9c886acb32f5664e3bfd0640e6fc1de6525b8f6103f25906d040d054ce07\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://551e3b7d18d5e83727491f6749643a9a1e9a2e253a1a9be56eeb44e4c1b13876\",\"dweb:/ipfs/QmSpGRSD3DDP1EbBbXDPqAbSP58roEvCsosMQCDtSDnEBa\"]},\"contracts/IERC20.sol\":{\"keccak256\":\"0x91104f4bcc877f2506e4485b871efe0a6beb5c1ef7de9c374d99d75289905905\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://57a7ecbec5ff542c117d36c7487386b5653ad21d0a83414e859d4202e069b36f\",\"dweb:/ipfs/QmaPocSUaysdjd1Ksa5kttxRHxhA7XWd6HrQ9teLFRyR6W\"]},\"contracts/IERC20Permit.sol\":{\"keccak256\":\"0x08d82b52e80c1a83f792c519388ca1ae86ae441bdfbd7d84addc82ef9c499a9e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a5449dde3b5541f3f653b352bfa0aa4f3e91ab24a110106319baa83940f540a5\",\"dweb:/ipfs/QmUuadcLdSPtqMuuhBgkdAZHrE3tx5rdQ7HCXCsa8RDaTU\"]},\"contracts/IERC7597Permit.sol\":{\"keccak256\":\"0x550ff037524afe9ef46d2c54ed59f4048c4216122e80da3b17872e05c163a74e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://40df00df81d4a4d2a78105bf5b86694037d885abf30e1e47e286b6e3310bdf48\",\"dweb:/ipfs/QmVqmS8BpSMV8PeiUme1tNDq48zfn71XYxWhb6fLtxCT6f\"]},\"contracts/IPermit2.sol\":{\"keccak256\":\"0x79e985eddaf616078cde10431fb615b577ba83b96ca5f4161cb82939a787a195\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a1d3243656736b7e4422a6eb7bbac982760f99674b9d80286e5bf45f1fe04376\",\"dweb:/ipfs/QmacX52RVqLnUgWxji9FkfFSZeGnV6qdxkkX5kMxakYRyW\"]},\"contracts/IWETH.sol\":{\"keccak256\":\"0x2dc6d61d66f1881a6c273b5f30f9a82e6eda4988c7aeaf0b26549a5e10c9fcb9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1695d9fd49960e732d2228a304fe9bc221439293e940fdcb9c17419ccafdcfc1\",\"dweb:/ipfs/QmPZrdz4icyWQeR5Yf1zDQnpH8MmYiHyKofVcwvwNADjRh\"]},\"contracts/RevertReasonForwarder.sol\":{\"keccak256\":\"0x00dbd12fec0c2696dd0862143457d8a23c998dcabd5d038fc85512ba93467417\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2fa738dc80ff7027762294869f2b181177a5c122fe04ceea08c619c544c820aa\",\"dweb:/ipfs/QmUzrDWe6k6Hhfdd5MxUhnW34B8mGJ5pwx65NM9EBLkLCU\"]},\"contracts/SafeERC20.sol\":{\"keccak256\":\"0x2cdc46994aa3302bf2026f5a2ba0650398aaf41278354075544bf42350ee947e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6a65e24d410030f7b192d59a0096213bee88b963822052502572cdb9ee55e9d9\",\"dweb:/ipfs/QmcQH7uVFhTLGxTuqUsiEsc7qH9HE7xGgSQTXijoVUcKUn\"]},\"contracts/escrow/BaseEscrow.sol\":{\"keccak256\":\"0x1436c940fcfbeb3c3248055e1b50184f41df8108362ff40db0183814c6311d89\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://635dbe2acc93061e09b7db75dafe8bb9ae6f72dd6901cd304015869f1cdbe4b8\",\"dweb:/ipfs/QmZ6jF22Liy5tERu5faTNdhXgsUSTdv5xsB3bmaDZiHJiK\"]},\"contracts/escrow/Create2.sol\":{\"keccak256\":\"0x02f0faa500d9ca42186fd2f4d7f381777cd2970bfa2fd7fb542c309361aae81c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5f45127145cf2abd405d732ccaeaf467d853a3779bc85e090133e6005d197a4\",\"dweb:/ipfs/Qmdg1VaKkAWQ1qcVWYr9cRuoeGhg2QvrJPyDukyR7dwf8d\"]},\"contracts/escrow/Escrow.sol\":{\"keccak256\":\"0x718d6ffede1758a543b6d76f329130015f8af696e17178d5661c81b35d9f9839\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8e910017a35b6888d255e2791790c192a588b41c6d2b9c239199c0c2317add84\",\"dweb:/ipfs/QmXKnin4x6MPWeyTgxiLzvWj11NxxAEcu7JGzjUoGETb1g\"]},\"contracts/escrow/EscrowSrc.sol\":{\"keccak256\":\"0xd13024388bd16a3435b14292fe65e6e4a98c95d9312803980c15425614c3b7e3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://01486c56b8b62b4a58fb291d9e6899d7854df4b4d2c3065777a0f549ed3633ae\",\"dweb:/ipfs/QmUc8s3yGBBs7K1XANGt1MK7yWusne2srr4dQYW2Gt2eQH\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/interfaces/IEscrow.sol\":{\"keccak256\":\"0x8b0063cd06290dfc5d4bb20a9bdddff356f3100bd63d5a0c3f1b8d30d028fc10\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://78e81dc1ba169a0f328efc4824192f8906189e3cb2ed263543ecd1f9a61b7ac6\",\"dweb:/ipfs/QmeaB5ymsLYZhUXrt4TFW6qYBPgLgUMEoAhggqAscZ2pNq\"]},\"contracts/escrow/interfaces/IEscrowSrc.sol\":{\"keccak256\":\"0x76ef7eb0c58fcfe8dde20f2acf68265c499a437c3c7c8257939786dfb47599e1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bddd9b9fe6497e97e6fd5c1114975cedb6121ff8566c2a1aac7b00f282aba950\",\"dweb:/ipfs/QmTZHxsuatoZMNpCnfuM9UgnRWcyQF3NyztbusimAQiXrG\"]},\"contracts/escrow/libraries/ImmutablesLib.sol\":{\"keccak256\":\"0x61b4a772ba17cbb1e52d09c71903d694a6f032c7c3bff76ba109a2d2b606fcca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fdb8ddefa42e86bc8456c01bada27d8d68e52a64c1f117fc939df6052ca9f93b\",\"dweb:/ipfs/QmciZYyGkJHxsoDQHGnXYCf9R6eKpHz88L161MMiozTvwH\"]},\"contracts/escrow/libraries/ProxyHashLib.sol\":{\"keccak256\":\"0x9e899d11aa1548e1f30a61ad87668b0dfd2b3464fbc1abef8ec95352c8c34c0d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://69ec0c4598b490cb0146872af15dd06e490db823efb3e60c6d500e62deb49689\",\"dweb:/ipfs/QmdfEwW8nzfHN9HpDRh8DKR2LrVWLXpJrig28aHhFkNUp3\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"EscrowCancelled()": {
								"notice": "Emitted on escrow cancellation."
							},
							"EscrowWithdrawal(bytes32)": {
								"notice": "Emitted on successful withdrawal."
							},
							"FundsRescued(address,uint256)": {
								"notice": "Emitted when funds are rescued."
							}
						},
						"kind": "user",
						"methods": {
							"FACTORY()": {
								"notice": "See {IBaseEscrow-FACTORY}."
							},
							"PROXY_BYTECODE_HASH()": {
								"notice": "See {IEscrow-PROXY_BYTECODE_HASH}."
							},
							"RESCUE_DELAY()": {
								"notice": "See {IBaseEscrow-RESCUE_DELAY}."
							},
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IBaseEscrow-cancel}."
							},
							"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IEscrowSrc-publicCancel}."
							},
							"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IEscrowSrc-publicWithdraw}."
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IBaseEscrow-rescueFunds}."
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IBaseEscrow-withdraw}."
							},
							"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "See {IEscrowSrc-withdrawTo}."
							}
						},
						"notice": "Contract to initially lock funds and then unlock them with verification of the secret presented.",
						"version": 1
					}
				}
			},
			"contracts/escrow/interfaces/IBaseEscrow.sol": {
				"IBaseEscrow": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidCaller",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidImmutables",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidSecret",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidTime",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "NativeTokenSendingFailure",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [],
							"name": "EscrowCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								}
							],
							"name": "EscrowWithdrawal",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "FundsRescued",
							"type": "event"
						},
						{
							"inputs": [],
							"name": "FACTORY",
							"outputs": [
								{
									"internalType": "address",
									"name": "",
									"type": "address"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "RESCUE_DELAY",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "cancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "rescueFunds",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"events": {
							"EscrowWithdrawal(bytes32)": {
								"params": {
									"secret": "The secret that unlocks the escrow."
								}
							},
							"FundsRescued(address,uint256)": {
								"params": {
									"amount": "The amount of tokens rescued.",
									"token": "The address of the token rescued. Zero address for native token."
								}
							}
						},
						"kind": "dev",
						"methods": {
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract."
								}
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Funds can only be rescued by the taker after the rescue delay.",
								"params": {
									"amount": "The amount of tokens to rescue.",
									"immutables": "The immutables of the escrow contract.",
									"token": "The address of the token to rescue. Zero address for native token."
								}
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow."
								}
							}
						},
						"title": "Base Escrow interface for cross-chain atomic swap.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImmutables\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecret\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenSendingFailure\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"EscrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"events\":{\"EscrowWithdrawal(bytes32)\":{\"params\":{\"secret\":\"The secret that unlocks the escrow.\"}},\"FundsRescued(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens rescued.\",\"token\":\"The address of the token rescued. Zero address for native token.\"}}},\"kind\":\"dev\",\"methods\":{\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\"}},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Funds can only be rescued by the taker after the rescue delay.\",\"params\":{\"amount\":\"The amount of tokens to rescue.\",\"immutables\":\"The immutables of the escrow contract.\",\"token\":\"The address of the token to rescue. Zero address for native token.\"}},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\"}}},\"title\":\"Base Escrow interface for cross-chain atomic swap.\",\"version\":1},\"userdoc\":{\"events\":{\"EscrowCancelled()\":{\"notice\":\"Emitted on escrow cancellation.\"},\"EscrowWithdrawal(bytes32)\":{\"notice\":\"Emitted on successful withdrawal.\"},\"FundsRescued(address,uint256)\":{\"notice\":\"Emitted when funds are rescued.\"}},\"kind\":\"user\",\"methods\":{\"FACTORY()\":{\"notice\":\"Returns the address of the factory that created the escrow.\"},\"RESCUE_DELAY()\":{\"notice\":\"Returns the delay for rescuing funds from the escrow.\"},\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Cancels the escrow and returns tokens to a predetermined recipient.\"},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Rescues funds from the escrow.\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to a predetermined recipient.\"}},\"notice\":\"Interface implies locking funds initially and then unlocking them with verification of the secret presented.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/interfaces/IBaseEscrow.sol\":\"IBaseEscrow\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"EscrowCancelled()": {
								"notice": "Emitted on escrow cancellation."
							},
							"EscrowWithdrawal(bytes32)": {
								"notice": "Emitted on successful withdrawal."
							},
							"FundsRescued(address,uint256)": {
								"notice": "Emitted when funds are rescued."
							}
						},
						"kind": "user",
						"methods": {
							"FACTORY()": {
								"notice": "Returns the address of the factory that created the escrow."
							},
							"RESCUE_DELAY()": {
								"notice": "Returns the delay for rescuing funds from the escrow."
							},
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Cancels the escrow and returns tokens to a predetermined recipient."
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Rescues funds from the escrow."
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to a predetermined recipient."
							}
						},
						"notice": "Interface implies locking funds initially and then unlocking them with verification of the secret presented.",
						"version": 1
					}
				}
			},
			"contracts/escrow/interfaces/IEscrow.sol": {
				"IEscrow": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidCaller",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidImmutables",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidSecret",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidTime",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "NativeTokenSendingFailure",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [],
							"name": "EscrowCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								}
							],
							"name": "EscrowWithdrawal",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "FundsRescued",
							"type": "event"
						},
						{
							"inputs": [],
							"name": "FACTORY",
							"outputs": [
								{
									"internalType": "address",
									"name": "",
									"type": "address"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "PROXY_BYTECODE_HASH",
							"outputs": [
								{
									"internalType": "bytes32",
									"name": "",
									"type": "bytes32"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "RESCUE_DELAY",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "cancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "rescueFunds",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"events": {
							"EscrowWithdrawal(bytes32)": {
								"params": {
									"secret": "The secret that unlocks the escrow."
								}
							},
							"FundsRescued(address,uint256)": {
								"params": {
									"amount": "The amount of tokens rescued.",
									"token": "The address of the token rescued. Zero address for native token."
								}
							}
						},
						"kind": "dev",
						"methods": {
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract."
								}
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Funds can only be rescued by the taker after the rescue delay.",
								"params": {
									"amount": "The amount of tokens to rescue.",
									"immutables": "The immutables of the escrow contract.",
									"token": "The address of the token to rescue. Zero address for native token."
								}
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow."
								}
							}
						},
						"title": "Escrow interface for cross-chain atomic swap.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImmutables\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecret\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenSendingFailure\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"EscrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROXY_BYTECODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"events\":{\"EscrowWithdrawal(bytes32)\":{\"params\":{\"secret\":\"The secret that unlocks the escrow.\"}},\"FundsRescued(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens rescued.\",\"token\":\"The address of the token rescued. Zero address for native token.\"}}},\"kind\":\"dev\",\"methods\":{\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\"}},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Funds can only be rescued by the taker after the rescue delay.\",\"params\":{\"amount\":\"The amount of tokens to rescue.\",\"immutables\":\"The immutables of the escrow contract.\",\"token\":\"The address of the token to rescue. Zero address for native token.\"}},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\"}}},\"title\":\"Escrow interface for cross-chain atomic swap.\",\"version\":1},\"userdoc\":{\"events\":{\"EscrowCancelled()\":{\"notice\":\"Emitted on escrow cancellation.\"},\"EscrowWithdrawal(bytes32)\":{\"notice\":\"Emitted on successful withdrawal.\"},\"FundsRescued(address,uint256)\":{\"notice\":\"Emitted when funds are rescued.\"}},\"kind\":\"user\",\"methods\":{\"FACTORY()\":{\"notice\":\"Returns the address of the factory that created the escrow.\"},\"PROXY_BYTECODE_HASH()\":{\"notice\":\"Returns the bytecode hash of the proxy contract.\"},\"RESCUE_DELAY()\":{\"notice\":\"Returns the delay for rescuing funds from the escrow.\"},\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Cancels the escrow and returns tokens to a predetermined recipient.\"},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Rescues funds from the escrow.\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to a predetermined recipient.\"}},\"notice\":\"Interface implies locking funds initially and then unlocking them with verification of the secret presented.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/interfaces/IEscrow.sol\":\"IEscrow\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/interfaces/IEscrow.sol\":{\"keccak256\":\"0x8b0063cd06290dfc5d4bb20a9bdddff356f3100bd63d5a0c3f1b8d30d028fc10\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://78e81dc1ba169a0f328efc4824192f8906189e3cb2ed263543ecd1f9a61b7ac6\",\"dweb:/ipfs/QmeaB5ymsLYZhUXrt4TFW6qYBPgLgUMEoAhggqAscZ2pNq\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"EscrowCancelled()": {
								"notice": "Emitted on escrow cancellation."
							},
							"EscrowWithdrawal(bytes32)": {
								"notice": "Emitted on successful withdrawal."
							},
							"FundsRescued(address,uint256)": {
								"notice": "Emitted when funds are rescued."
							}
						},
						"kind": "user",
						"methods": {
							"FACTORY()": {
								"notice": "Returns the address of the factory that created the escrow."
							},
							"PROXY_BYTECODE_HASH()": {
								"notice": "Returns the bytecode hash of the proxy contract."
							},
							"RESCUE_DELAY()": {
								"notice": "Returns the delay for rescuing funds from the escrow."
							},
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Cancels the escrow and returns tokens to a predetermined recipient."
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Rescues funds from the escrow."
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to a predetermined recipient."
							}
						},
						"notice": "Interface implies locking funds initially and then unlocking them with verification of the secret presented.",
						"version": 1
					}
				}
			},
			"contracts/escrow/interfaces/IEscrowSrc.sol": {
				"IEscrowSrc": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidCaller",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidImmutables",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidSecret",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidTime",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "NativeTokenSendingFailure",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [],
							"name": "EscrowCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								}
							],
							"name": "EscrowWithdrawal",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": false,
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								}
							],
							"name": "FundsRescued",
							"type": "event"
						},
						{
							"inputs": [],
							"name": "FACTORY",
							"outputs": [
								{
									"internalType": "address",
									"name": "",
									"type": "address"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "PROXY_BYTECODE_HASH",
							"outputs": [
								{
									"internalType": "bytes32",
									"name": "",
									"type": "bytes32"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "RESCUE_DELAY",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "cancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "publicCancel",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "publicWithdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "token",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "amount",
									"type": "uint256"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "rescueFunds",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdraw",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "bytes32",
									"name": "secret",
									"type": "bytes32"
								},
								{
									"internalType": "address",
									"name": "target",
									"type": "address"
								},
								{
									"components": [
										{
											"internalType": "bytes32",
											"name": "orderHash",
											"type": "bytes32"
										},
										{
											"internalType": "bytes32",
											"name": "hashlock",
											"type": "bytes32"
										},
										{
											"internalType": "Address",
											"name": "maker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "taker",
											"type": "uint256"
										},
										{
											"internalType": "Address",
											"name": "token",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "amount",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "safetyDeposit",
											"type": "uint256"
										},
										{
											"internalType": "Timelocks",
											"name": "timelocks",
											"type": "uint256"
										}
									],
									"internalType": "struct IBaseEscrow.Immutables",
									"name": "immutables",
									"type": "tuple"
								}
							],
							"name": "withdrawTo",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						}
					],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"events": {
							"EscrowWithdrawal(bytes32)": {
								"params": {
									"secret": "The secret that unlocks the escrow."
								}
							},
							"FundsRescued(address,uint256)": {
								"params": {
									"amount": "The amount of tokens rescued.",
									"token": "The address of the token rescued. Zero address for native token."
								}
							}
						},
						"kind": "dev",
						"methods": {
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract."
								}
							},
							"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "The escrow can only be cancelled during the public cancellation period. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract."
								}
							},
							"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the public withdrawal period and with secret with hash matches the hashlock.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow."
								}
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Funds can only be rescued by the taker after the rescue delay.",
								"params": {
									"amount": "The amount of tokens to rescue.",
									"immutables": "The immutables of the escrow contract.",
									"token": "The address of the token to rescue. Zero address for native token."
								}
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow."
								}
							},
							"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"details": "Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.",
								"params": {
									"immutables": "The immutables of the escrow contract.",
									"secret": "The secret that unlocks the escrow.",
									"target": "The address to withdraw the funds to."
								}
							}
						},
						"title": "Source Escrow interface for cross-chain atomic swap.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImmutables\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSecret\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenSendingFailure\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"EscrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROXY_BYTECODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESCUE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"publicCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"publicWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"taker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyDeposit\",\"type\":\"uint256\"},{\"internalType\":\"Timelocks\",\"name\":\"timelocks\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseEscrow.Immutables\",\"name\":\"immutables\",\"type\":\"tuple\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"events\":{\"EscrowWithdrawal(bytes32)\":{\"params\":{\"secret\":\"The secret that unlocks the escrow.\"}},\"FundsRescued(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens rescued.\",\"token\":\"The address of the token rescued. Zero address for native token.\"}}},\"kind\":\"dev\",\"methods\":{\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The escrow can only be cancelled during the cancellation period. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\"}},\"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"The escrow can only be cancelled during the public cancellation period. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\"}},\"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the public withdrawal period and with secret with hash matches the hashlock.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\"}},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Funds can only be rescued by the taker after the rescue delay.\",\"params\":{\"amount\":\"The amount of tokens to rescue.\",\"immutables\":\"The immutables of the escrow contract.\",\"token\":\"The address of the token to rescue. Zero address for native token.\"}},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\"}},\"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock. The safety deposit is sent to the caller.\",\"params\":{\"immutables\":\"The immutables of the escrow contract.\",\"secret\":\"The secret that unlocks the escrow.\",\"target\":\"The address to withdraw the funds to.\"}}},\"title\":\"Source Escrow interface for cross-chain atomic swap.\",\"version\":1},\"userdoc\":{\"events\":{\"EscrowCancelled()\":{\"notice\":\"Emitted on escrow cancellation.\"},\"EscrowWithdrawal(bytes32)\":{\"notice\":\"Emitted on successful withdrawal.\"},\"FundsRescued(address,uint256)\":{\"notice\":\"Emitted when funds are rescued.\"}},\"kind\":\"user\",\"methods\":{\"FACTORY()\":{\"notice\":\"Returns the address of the factory that created the escrow.\"},\"PROXY_BYTECODE_HASH()\":{\"notice\":\"Returns the bytecode hash of the proxy contract.\"},\"RESCUE_DELAY()\":{\"notice\":\"Returns the delay for rescuing funds from the escrow.\"},\"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Cancels the escrow and returns tokens to a predetermined recipient.\"},\"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Cancels the escrow and returns tokens to the maker.\"},\"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to the taker.\"},\"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Rescues funds from the escrow.\"},\"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to a predetermined recipient.\"},\"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Withdraws funds to a specified target.\"}},\"notice\":\"Interface implies locking funds initially and then unlocking them with verification of the secret presented.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/interfaces/IEscrowSrc.sol\":\"IEscrowSrc\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/interfaces/IEscrow.sol\":{\"keccak256\":\"0x8b0063cd06290dfc5d4bb20a9bdddff356f3100bd63d5a0c3f1b8d30d028fc10\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://78e81dc1ba169a0f328efc4824192f8906189e3cb2ed263543ecd1f9a61b7ac6\",\"dweb:/ipfs/QmeaB5ymsLYZhUXrt4TFW6qYBPgLgUMEoAhggqAscZ2pNq\"]},\"contracts/escrow/interfaces/IEscrowSrc.sol\":{\"keccak256\":\"0x76ef7eb0c58fcfe8dde20f2acf68265c499a437c3c7c8257939786dfb47599e1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bddd9b9fe6497e97e6fd5c1114975cedb6121ff8566c2a1aac7b00f282aba950\",\"dweb:/ipfs/QmTZHxsuatoZMNpCnfuM9UgnRWcyQF3NyztbusimAQiXrG\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"events": {
							"EscrowCancelled()": {
								"notice": "Emitted on escrow cancellation."
							},
							"EscrowWithdrawal(bytes32)": {
								"notice": "Emitted on successful withdrawal."
							},
							"FundsRescued(address,uint256)": {
								"notice": "Emitted when funds are rescued."
							}
						},
						"kind": "user",
						"methods": {
							"FACTORY()": {
								"notice": "Returns the address of the factory that created the escrow."
							},
							"PROXY_BYTECODE_HASH()": {
								"notice": "Returns the bytecode hash of the proxy contract."
							},
							"RESCUE_DELAY()": {
								"notice": "Returns the delay for rescuing funds from the escrow."
							},
							"cancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Cancels the escrow and returns tokens to a predetermined recipient."
							},
							"publicCancel((bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Cancels the escrow and returns tokens to the maker."
							},
							"publicWithdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to the taker."
							},
							"rescueFunds(address,uint256,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Rescues funds from the escrow."
							},
							"withdraw(bytes32,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to a predetermined recipient."
							},
							"withdrawTo(bytes32,address,(bytes32,bytes32,uint256,uint256,uint256,uint256,uint256,uint256))": {
								"notice": "Withdraws funds to a specified target."
							}
						},
						"notice": "Interface implies locking funds initially and then unlocking them with verification of the secret presented.",
						"version": 1
					}
				}
			},
			"contracts/escrow/libraries/ImmutablesLib.sol": {
				"ImmutablesLib": {
					"abi": [],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"kind": "dev",
						"methods": {},
						"title": "Library for escrow immutables.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220701ec67146a2942c1f54cb3bfee08f95049b7093dd51422c28686c73f6b2f9d164736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH17 0x1EC67146A2942C1F54CB3BFEE08F95049B PUSH17 0x93DD51422C28686C73F6B2F9D164736F6C PUSH4 0x43000817 STOP CALLER ",
							"sourceMap": "216:922:17:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea2646970667358221220701ec67146a2942c1f54cb3bfee08f95049b7093dd51422c28686c73f6b2f9d164736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH17 0x1EC67146A2942C1F54CB3BFEE08F95049B PUSH17 0x93DD51422C28686C73F6B2F9D164736F6C PUSH4 0x43000817 STOP CALLER ",
							"sourceMap": "216:922:17:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"kind\":\"dev\",\"methods\":{},\"title\":\"Library for escrow immutables.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/libraries/ImmutablesLib.sol\":\"ImmutablesLib\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/AddressLib.sol\":{\"keccak256\":\"0x5dbbd2513216eca9660b83e356b1b50d6dd5f854c0106be6bc7df3fff01821d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://71c5a3b82d7cb1c060885ed6a11710fe216af832d30b6dd30d051635e6c4e586\",\"dweb:/ipfs/QmWYnTddAxLhKQq58wwya9NUkhudFoYamGZpcuHc6XdAMR\"]},\"contracts/escrow/interfaces/IBaseEscrow.sol\":{\"keccak256\":\"0xe04d997a41e2fb0df08f6eee1519944d7e226d9d816115cc2a6977860c863724\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ef01bf4cb93bc9f2ccb0ada3780ae8aae98c59300e1fa40efd1a1211bf2dabe4\",\"dweb:/ipfs/QmSY8bq7C9ZVqHmtuC8kQPAMsg3o2bB2y688JPCGoohZhX\"]},\"contracts/escrow/libraries/ImmutablesLib.sol\":{\"keccak256\":\"0x61b4a772ba17cbb1e52d09c71903d694a6f032c7c3bff76ba109a2d2b606fcca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fdb8ddefa42e86bc8456c01bada27d8d68e52a64c1f117fc939df6052ca9f93b\",\"dweb:/ipfs/QmciZYyGkJHxsoDQHGnXYCf9R6eKpHz88L161MMiozTvwH\"]},\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"contracts/escrow/libraries/ProxyHashLib.sol": {
				"ProxyHashLib": {
					"abi": [],
					"devdoc": {
						"custom:security-contact": "security@1inch.io",
						"kind": "dev",
						"methods": {},
						"title": "Library to compute the hash of the proxy bytecode.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220f8da26aebaa4ccf2246a28429c55e72d2c537f76bc3c401221475701e295e1f864736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xF8 0xDA 0x26 0xAE 0xBA LOG4 0xCC CALLCODE 0x24 PUSH11 0x28429C55E72D2C537F76BC EXTCODECOPY BLOCKHASH SLT 0x21 SELFBALANCE JUMPI ADD 0xE2 SWAP6 0xE1 0xF8 PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "174:883:18:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea2646970667358221220f8da26aebaa4ccf2246a28429c55e72d2c537f76bc3c401221475701e295e1f864736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xF8 0xDA 0x26 0xAE 0xBA LOG4 0xCC CALLCODE 0x24 PUSH11 0x28429C55E72D2C537F76BC EXTCODECOPY BLOCKHASH SLT 0x21 SELFBALANCE JUMPI ADD 0xE2 SWAP6 0xE1 0xF8 PUSH5 0x736F6C6343 STOP ADDMOD OR STOP CALLER ",
							"sourceMap": "174:883:18:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"custom:security-contact\":\"security@1inch.io\",\"kind\":\"dev\",\"methods\":{},\"title\":\"Library to compute the hash of the proxy bytecode.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/libraries/ProxyHashLib.sol\":\"ProxyHashLib\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/escrow/libraries/ProxyHashLib.sol\":{\"keccak256\":\"0x9e899d11aa1548e1f30a61ad87668b0dfd2b3464fbc1abef8ec95352c8c34c0d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://69ec0c4598b490cb0146872af15dd06e490db823efb3e60c6d500e62deb49689\",\"dweb:/ipfs/QmdfEwW8nzfHN9HpDRh8DKR2LrVWLXpJrig28aHhFkNUp3\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"contracts/escrow/libraries/TimelocksLib.sol": {
				"TimelocksLib": {
					"abi": [],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"title": "Timelocks library for compact storage of timelocks in a uint256.",
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122031e550ccabc4bfc871c529f4c44156afecc37043848f0a2026f4a5abc6aadd6d64736f6c63430008170033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x39 SWAP1 DUP2 PUSH1 0x1C DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH0 DUP1 REVERT INVALID PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 BALANCE 0xE5 POP 0xCC 0xAB 0xC4 0xBF 0xC8 PUSH18 0xC529F4C44156AFECC37043848F0A2026F4A5 0xAB 0xC6 0xAA 0xDD PUSH14 0x64736F6C63430008170033000000 ",
							"sourceMap": "1200:1882:19:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "5f80fdfea264697066735822122031e550ccabc4bfc871c529f4c44156afecc37043848f0a2026f4a5abc6aadd6d64736f6c63430008170033",
							"opcodes": "PUSH0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 BALANCE 0xE5 POP 0xCC 0xAB 0xC4 0xBF 0xC8 PUSH18 0xC529F4C44156AFECC37043848F0A2026F4A5 0xAB 0xC6 0xAA 0xDD PUSH14 0x64736F6C63430008170033000000 ",
							"sourceMap": "1200:1882:19:-:0;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"Timelocks library for compact storage of timelocks in a uint256.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/escrow/libraries/TimelocksLib.sol\":\"TimelocksLib\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/escrow/libraries/TimelocksLib.sol\":{\"keccak256\":\"0xd6ad5f65d792a1bc4c40328afed51281b7855ebf69696125cbbec42b695e9379\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://db449fb7a9bd6d334ed5aeb4e14297a729e2a97fbf20b22821e18446b67bbaf2\",\"dweb:/ipfs/QmXUUBE2dyAF922kCaxhqDr1yL1s7t44di44ewWzEoKG3d\"]}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			}
		},
		"sources": {
			"contracts/AddressLib.sol": {
				"id": 0
			},
			"contracts/Errors.sol": {
				"id": 1
			},
			"contracts/IDaiLikePermit.sol": {
				"id": 2
			},
			"contracts/IERC20.sol": {
				"id": 3
			},
			"contracts/IERC20Permit.sol": {
				"id": 4
			},
			"contracts/IERC7597Permit.sol": {
				"id": 5
			},
			"contracts/IPermit2.sol": {
				"id": 6
			},
			"contracts/IWETH.sol": {
				"id": 7
			},
			"contracts/RevertReasonForwarder.sol": {
				"id": 8
			},
			"contracts/SafeERC20.sol": {
				"id": 9
			},
			"contracts/escrow/BaseEscrow.sol": {
				"id": 10
			},
			"contracts/escrow/Create2.sol": {
				"id": 11
			},
			"contracts/escrow/Escrow.sol": {
				"id": 12
			},
			"contracts/escrow/EscrowSrc.sol": {
				"id": 13
			},
			"contracts/escrow/interfaces/IBaseEscrow.sol": {
				"id": 14
			},
			"contracts/escrow/interfaces/IEscrow.sol": {
				"id": 15
			},
			"contracts/escrow/interfaces/IEscrowSrc.sol": {
				"id": 16
			},
			"contracts/escrow/libraries/ImmutablesLib.sol": {
				"id": 17
			},
			"contracts/escrow/libraries/ProxyHashLib.sol": {
				"id": 18
			},
			"contracts/escrow/libraries/TimelocksLib.sol": {
				"id": 19
			}
		}
	}
}